/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators'
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs'
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core'
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http'

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL')

@Injectable({
  providedIn: 'root',
})
export class AccountClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changePassword(body: ChangePasswordCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/account/change-password'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processChangePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeEmail(body: ChangeEmailCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/account/change-email'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeEmail(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeEmail(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processChangeEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
 * @param body (optional)
 * @return Success
 */
  deleteAccount(body: DeleteAccountCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/account/delete-account'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteAccount(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteAccount(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processDeleteAccount(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class AchievementsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  achievementsGet(): Observable<ListUserAchievementsViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/achievements'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAchievementsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAchievementsGet(<any>response_)
            } catch (e) {
              return <Observable<ListUserAchievementsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListUserAchievementsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAchievementsGet(
    response: HttpResponseBase
  ): Observable<ListUserAchievementsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListUserAchievementsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserAchievementsViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  achievementsPost(body: AddAchievementCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/profile/achievements'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAchievementsPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAchievementsPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAchievementsPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  achievementsPut(id: string, body: EditAchievementCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/achievements/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAchievementsPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAchievementsPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAchievementsPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  achievementsDelete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/achievements/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAchievementsDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAchievementsDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAchievementsDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ArticlesClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  articlesGet(): Observable<ListArticlesViewModel[]> {
    let url_ = this.baseUrl + '/api/articles'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticlesGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticlesGet(<any>response_)
            } catch (e) {
              return <Observable<ListArticlesViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListArticlesViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processArticlesGet(response: HttpResponseBase): Observable<ListArticlesViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListArticlesViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListArticlesViewModel[]>(<any>null)
  }

  /**
   * @param file (optional)
   * @param articleId (optional)
   * @param description (optional)
   * @param name (optional)
   * @param theArticle (optional)
   * @param articleStatus (optional)
   * @param date (optional)
   * @return Success
   */
  articlesPost(
    file: FileParameter | null | undefined,
    thumbnailfile: FileParameter | null | undefined,
    articleId: string | undefined,
    description: string | null | undefined,
    name: string | null | undefined,
    theArticle: string | null | undefined,
    articleStatus: number | undefined,
    date: Date | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/articles'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('orignalFile', file.data, file.fileName ? file.fileName : 'file')
    if (thumbnailfile !== null && thumbnailfile !== undefined)
      content_.append('thumbnailFile', thumbnailfile.data, thumbnailfile.fileName ? thumbnailfile.fileName : 'thumbnailfile')
    if (articleId) content_.append('articleId', articleId.toString())
    if (description !== null && description !== undefined)
      content_.append('description', description.toString())
    if (name !== null && name !== undefined) content_.append('name', name.toString())
    if (theArticle !== null && theArticle !== undefined)
      content_.append('theArticle', theArticle.toString())
    if (articleStatus === null || articleStatus === undefined)
      throw new Error("The parameter 'articleStatus' cannot be null.")
    else content_.append('articleStatus', articleStatus.toString())
    if (date !== null && date !== undefined) content_.append('date', date.toJSON())

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticlesPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticlesPost(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processArticlesPost(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  userArticles(): Observable<ListUserArticlesViewModel[]> {
    let url_ = this.baseUrl + '/api/articles/user-articles'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserArticles(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserArticles(<any>response_)
            } catch (e) {
              return <Observable<ListUserArticlesViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListUserArticlesViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUserArticles(
    response: HttpResponseBase
  ): Observable<ListUserArticlesViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListUserArticlesViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserArticlesViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  search(text: string | null): Observable<SearchArticlesViewModel[]> {
    let url_ = this.baseUrl + '/api/articles/search/{text}'
    if (text === undefined || text === null)
      throw new Error("The parameter 'text' must be defined.")
    url_ = url_.replace('{text}', encodeURIComponent('' + text))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSearch(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSearch(<any>response_)
            } catch (e) {
              return <Observable<SearchArticlesViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<SearchArticlesViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSearch(response: HttpResponseBase): Observable<SearchArticlesViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(SearchArticlesViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<SearchArticlesViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  searchUserArticles(text: string | null): Observable<SearchUserArticlesViewModel[]> {
    let url_ = this.baseUrl + '/api/articles/search-user-articles/{text}'
    if (text === undefined || text === null)
      throw new Error("The parameter 'text' must be defined.")
    url_ = url_.replace('{text}', encodeURIComponent('' + text))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSearchUserArticles(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSearchUserArticles(<any>response_)
            } catch (e) {
              return <Observable<SearchUserArticlesViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<SearchUserArticlesViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSearchUserArticles(
    response: HttpResponseBase
  ): Observable<SearchUserArticlesViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(SearchUserArticlesViewModel.fromJS(item))
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<SearchUserArticlesViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  articlesGetById(id: string): Observable<ListArticlesViewModel> {
    let url_ = this.baseUrl + '/api/articles/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processArticlesGetById(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processArticlesGetById(<any>response_)
            } catch (e) {
              return <Observable<ListArticlesViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListArticlesViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processArticlesGetById(response: HttpResponseBase): Observable<ListArticlesViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<ListArticlesViewModel>(<any>null)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListArticlesViewModel>(<any>responseBlob)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ChatClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  chat(moduleId: string): Observable<string> {
    let url_ = this.baseUrl + '/api/chat/{moduleId}'
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace('{moduleId}', encodeURIComponent('' + moduleId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChat(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChat(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processChat(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<string>(<any>_responseText)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @return Success
   */
  adminRooms(): Observable<any> {
    let url_ = this.baseUrl + '/api/chat/meeting-rooms'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdminRooms(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdminRooms(<any>response_)
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e))
            }
          } else return <Observable<any>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAdminRooms(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<any>(<any>null)
  }

  /**
   * @return Success
   */
  rooms(excludeUserId: string): Observable<any> {
    let url_ = this.baseUrl + '/api/chat/{excludeUserId}/rooms'
    if (excludeUserId === undefined || excludeUserId === null)
      throw new Error("The parameter 'excludeUserId' must be defined.")
    url_ = url_.replace('{excludeUserId}', encodeURIComponent('' + excludeUserId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRooms(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRooms(<any>response_)
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e))
            }
          } else return <Observable<any>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processRooms(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          return _observableOf<any>(<any>resultData200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<any>(<any>null)
  }

  /**
   * @param type (optional)
   * @return Success
   */
  messages(roomId: string, type: MessageTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/chat/{roomId}/messages?'
    if (roomId === undefined || roomId === null)
      throw new Error("The parameter 'roomId' must be defined.")
    url_ = url_.replace('{roomId}', encodeURIComponent('' + roomId))
    if (type === null) throw new Error("The parameter 'type' cannot be null.")
    else if (type !== undefined) url_ += 'type=' + encodeURIComponent('' + type) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMessages(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMessages(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processMessages(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<string>(<any>_responseText)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  room(body: CreateRoomCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/chat/room'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRoom(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRoom(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processRoom(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<string>(<any>_responseText)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @return Success
   */
  roomPost(userId: string, roomId: string): Observable<any> {
    let url_ = this.baseUrl + '/api/chat/{userId}/room/{roomId}'
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId))
    if (roomId === undefined || roomId === null)
      throw new Error("The parameter 'roomId' must be defined.")
    url_ = url_.replace('{roomId}', encodeURIComponent('' + roomId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRoomPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRoomPost(<any>response_)
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e))
            }
          } else return <Observable<any>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processRoomPost(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }

          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  roomDelete(userId: string, roomId: string): Observable<void> {
    let url_ = this.baseUrl + '/api/chat/{userId}/room/{roomId}'
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.")
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId))
    if (roomId === undefined || roomId === null)
      throw new Error("The parameter 'roomId' must be defined.")
    url_ = url_.replace('{roomId}', encodeURIComponent('' + roomId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRoomDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRoomDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processRoomDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param file (optional)
   * @return Success
   */
  upload(roomId: string, file: FileParameter | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/chat/{roomId}/upload'
    if (roomId === undefined || roomId === null)
      throw new Error("The parameter 'roomId' must be defined.")
    url_ = url_.replace('{roomId}', encodeURIComponent('' + roomId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpload(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpload(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUpload(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>_responseText)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param url (optional)
   * @return Success
   */
  download(roomId: string, url: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/chat/{roomId}/download?'
    if (roomId === undefined || roomId === null)
      throw new Error("The parameter 'roomId' must be defined.")
    url_ = url_.replace('{roomId}', encodeURIComponent('' + roomId))
    if (url !== undefined && url !== null) url_ += 'url=' + encodeURIComponent('' + url) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownload(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownload(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processDownload(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>responseBlob)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class DashboardClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @param id (optional)
   * @return Success
   */
  dashboard(id: string | null | undefined): Observable<DashboardViewModel[]> {
    let url_ = this.baseUrl + '/api/dashboard?'
    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDashboard(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDashboard(<any>response_)
            } catch (e) {
              return <Observable<DashboardViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<DashboardViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processDashboard(response: HttpResponseBase): Observable<DashboardViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          return _observableOf(resultData200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<DashboardViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class CalendarClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @param id (optional)
   * @return Success
   */
  calendar(id: string | null | undefined): Observable<GetUserCalendarViewModel[]> {
    let url_ = this.baseUrl + '/api/calendar?'
    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCalendar(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCalendar(<any>response_)
            } catch (e) {
              return <Observable<GetUserCalendarViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetUserCalendarViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processCalendar(response: HttpResponseBase): Observable<GetUserCalendarViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(GetUserCalendarViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetUserCalendarViewModel[]>(<any>null)
  }

  /**
   * @param id (optional)
   * @return Success
   */
  meetings(id: string | null | undefined): Observable<ListApplicantMeetingViewModel[]> {
    let url_ = this.baseUrl + '/api/calendar/meetings?'
    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMeetings(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMeetings(<any>response_)
            } catch (e) {
              return <Observable<ListApplicantMeetingViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListApplicantMeetingViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processMeetings(
    response: HttpResponseBase
  ): Observable<ListApplicantMeetingViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListApplicantMeetingViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class EliteClubClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  eliteclub(): Observable<EliteClubViewModel> {
    let url_ = this.baseUrl + '/api/eliteclub'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }
    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEliteclub(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEliteclub(<any>response_)
            } catch (e) {
              return <Observable<EliteClubViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<EliteClubViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEliteclub(response: HttpResponseBase): Observable<EliteClubViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          const result200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          return _observableOf<EliteClubViewModel>(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<EliteClubViewModel>(<any>null)
  }

  /**
   * @return Success
   */
  overview(id: string): Observable<EliteClubOverviewViewModel> {
    let url_ = this.baseUrl + '/api/eliteclub/overview/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOverview(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOverview(<any>response_)
            } catch (e) {
              return <Observable<EliteClubOverviewViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<EliteClubOverviewViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processOverview(response: HttpResponseBase): Observable<EliteClubOverviewViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          const result200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          return _observableOf<EliteClubOverviewViewModel>(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<EliteClubOverviewViewModel>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class EliteClubMembersClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  eliteclubMember(eliteClubId: string): Observable<ListEliteClubMembersByIdViewModel[]> {
    let url_ = this.baseUrl + '/api/eliteclub-member/{eliteClubId}'
    if (eliteClubId === undefined || eliteClubId === null)
      throw new Error("The parameter 'eliteClubId' must be defined.")
    url_ = url_.replace('{eliteClubId}', encodeURIComponent('' + eliteClubId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEliteclubMember(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEliteclubMember(<any>response_)
            } catch (e) {
              return <Observable<ListEliteClubMembersByIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListEliteClubMembersByIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processEliteclubMember(
    response: HttpResponseBase
  ): Observable<ListEliteClubMembersByIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListEliteClubMembersByIdViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListEliteClubMembersByIdViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class EliteMembershipAttendanceClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @param eliteClubId (optional)
   * @param membershipType (optional)
   * @return Success
   */
  eliteMembershipAttendanceGet(
    eliteClubId: string | undefined,
    membershipType: number | undefined
  ): Observable<Array<ElteMembershipAttendance>> {
    let url_ = this.baseUrl + '/api/elite-membership-attendance?'
    if (eliteClubId === null) throw new Error("The parameter 'eliteClubId' cannot be null.")
    else if (eliteClubId !== undefined)
      url_ += 'eliteClubId=' + encodeURIComponent('' + eliteClubId) + '&'
    if (membershipType === null) throw new Error("The parameter 'membershipType' cannot be null.")
    else if (membershipType !== undefined)
      url_ += 'membershipType=' + encodeURIComponent('' + membershipType) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEliteMembershipAttendanceGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEliteMembershipAttendanceGet(<any>response_)
            } catch (e) {
              return <Observable<Array<ElteMembershipAttendance>>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<Array<ElteMembershipAttendance>>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEliteMembershipAttendanceGet(
    response: HttpResponseBase
  ): Observable<Array<ElteMembershipAttendance>> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ElteMembershipAttendance.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<Array<ElteMembershipAttendance>>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  eliteMembershipAttendancePost(
    body: IUpdateMembershipAttendanceStatusCommand | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + '/api/elite-membership-attendance'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEliteMembershipAttendancePost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEliteMembershipAttendancePost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEliteMembershipAttendancePost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class EliteMentorSessionsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  eliteMentorSession(): Observable<ListEliteMentorSessionsViewModel[]> {
    let url_ = this.baseUrl + '/api/elite-mentor-session'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEliteMentorSession(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEliteMentorSession(<any>response_)
            } catch (e) {
              return <Observable<ListEliteMentorSessionsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListEliteMentorSessionsViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processEliteMentorSession(
    response: HttpResponseBase
  ): Observable<ListEliteMentorSessionsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListEliteMentorSessionsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListEliteMentorSessionsViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setDate(body: IUpdateEliteMentorSessionCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/elite-mentor-session/set-date'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetDate(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetDate(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSetDate(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ContentsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  sectionContents(sectionId: string): Observable<ListContentsBySectionIdViewModel[]> {
    let url_ = this.baseUrl + '/api/contents/section-contents/{sectionId}'
    if (sectionId === undefined || sectionId === null)
      throw new Error("The parameter 'sectionId' must be defined.")
    url_ = url_.replace('{sectionId}', encodeURIComponent('' + sectionId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSectionContents(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSectionContents(<any>response_)
            } catch (e) {
              return <Observable<ListContentsBySectionIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListContentsBySectionIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processSectionContents(
    response: HttpResponseBase
  ): Observable<ListContentsBySectionIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListContentsBySectionIdViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListContentsBySectionIdViewModel[]>(<any>null)
  }

  /**
   * @param file (optional)
   * @param sectionId (optional)
   * @param contentid (optional)
   * @param name (optional)
   * @param duration (optional)
   * @param order (optional)
   * @param type (optional)
   * @param text (optional)
   * @param url (optional)
   * @param startdate (optional)
   * @return Success
   */
  contentsPost(
    file: FileParameter | null | undefined,
    sectionId: string | undefined,
    contentid: string | null | undefined,
    name: string | null | undefined,
    duration: number | undefined,
    order: number | undefined,
    type: number | undefined,
    text: string | null | undefined,
    url: string | null | undefined,
    startdate?: Date | null | undefined
  ): Observable<any> {
    let url_ = this.baseUrl + '/api/contents'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')
    if (sectionId === null || sectionId === undefined)
      throw new Error("The parameter 'sectionId' cannot be null.")
    else content_.append('sectionId', sectionId.toString())
    if (contentid !== null && contentid !== undefined)
      content_.append('contentid', contentid.toString())
    if (name !== null && name !== undefined) content_.append('name', name.toString())
    if (duration === null || duration === undefined)
      throw new Error("The parameter 'duration' cannot be null.")
    else content_.append('duration', duration.toString())
    if (order === null || order === undefined)
      throw new Error("The parameter 'order' cannot be null.")
    else content_.append('order', order.toString())
    if (type === null || type === undefined) throw new Error("The parameter 'type' cannot be null.")
    else content_.append('type', type.toString())
    if (text !== null && text !== undefined) content_.append('text', text.toString())
    if (url !== null && url !== undefined) content_.append('url', url.toString())
    if (startdate !== null && startdate !== undefined)
      content_.append('startdate', startdate.toJSON())

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }
    return this.http.request('post', url_, options_)
  }

  /**
   * @return Success
   */
  contentsDelete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/contents/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processContentsDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processContentsDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processContentsDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class EducationQualificationsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  educationQualificationsGet(): Observable<ListUserEducationQualificationsViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/education-qualifications'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEducationQualificationsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEducationQualificationsGet(<any>response_)
            } catch (e) {
              return <Observable<ListUserEducationQualificationsViewModel[]>>(
                (<any>_observableThrow(e))
              )
            }
          } else
            return <Observable<ListUserEducationQualificationsViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processEducationQualificationsGet(
    response: HttpResponseBase
  ): Observable<ListUserEducationQualificationsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListUserEducationQualificationsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserEducationQualificationsViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  educationQualificationsPost(
    body: AddEducationQualificationCommand | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + '/api/profile/education-qualifications'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEducationQualificationsPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEducationQualificationsPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEducationQualificationsPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  educationQualificationsPut(
    id: string,
    body: EditEducationQualificationCommand | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/education-qualifications/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEducationQualificationsPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEducationQualificationsPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEducationQualificationsPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  educationQualificationsDelete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/education-qualifications/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEducationQualificationsDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEducationQualificationsDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEducationQualificationsDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class EnrollmentsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  enrollmentsGet(): Observable<ListEnrollmentByUserIdViewModel[]> {
    let url_ = this.baseUrl + '/api/enrollments'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEnrollmentsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEnrollmentsGet(<any>response_)
            } catch (e) {
              return <Observable<ListEnrollmentByUserIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListEnrollmentByUserIdViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEnrollmentsGet(
    response: HttpResponseBase
  ): Observable<ListEnrollmentByUserIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListEnrollmentByUserIdViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListEnrollmentByUserIdViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  enrollmentsPost(body: IAddEnrollmentCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/enrollments'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEnrollmentsPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEnrollmentsPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEnrollmentsPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @return Success
   */
  getVideoUploadStatus(enrollmentId: string): Promise<any> {
    let url_ = this.baseUrl + '/api/programs/check-upload-status/{id}'
    if (enrollmentId === undefined || enrollmentId === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + enrollmentId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'json',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return new Promise<any>((resolve) => {
      this.http.get(url_, options_).subscribe(data => {
        var resp: any = data
        resolve(resp?.body?.isUploaded == true)
      }, error => {
        resolve(null)
      });
    });
  }

  /**
   * @return Success
   */
  enrollmentsGetById(id: string): Observable<GetEnrollmentByIdViewModel> {
    let url_ = this.baseUrl + '/api/enrollments/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEnrollmentsGetById(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEnrollmentsGetById(<any>response_)
            } catch (e) {
              return <Observable<GetEnrollmentByIdViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetEnrollmentByIdViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEnrollmentsGetById(
    response: HttpResponseBase
  ): Observable<GetEnrollmentByIdViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = GetEnrollmentByIdViewModel.fromJS(resultData200)
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetEnrollmentByIdViewModel>(<any>null)
  }

  /**
   * @return Success
   */
  complete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/enrollments/{id}/complete'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processComplete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processComplete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processComplete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  answersGet(id: string): Observable<ListProgramAnswersByEnrollmentIdViewModel[]> {
    let url_ = this.baseUrl + '/api/enrollments/{id}/answers'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAnswersGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAnswersGet(<any>response_)
            } catch (e) {
              return <Observable<ListProgramAnswersByEnrollmentIdViewModel[]>>(
                (<any>_observableThrow(e))
              )
            }
          } else
            return <Observable<ListProgramAnswersByEnrollmentIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processAnswersGet(
    response: HttpResponseBase
  ): Observable<ListProgramAnswersByEnrollmentIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListProgramAnswersByEnrollmentIdViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListProgramAnswersByEnrollmentIdViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  answersPatch(id: string, body: AnswerForUpsertDto[] | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/enrollments/{id}/answers'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAnswersPatch(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAnswersPatch(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAnswersPatch(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  enrollmentStatus(id: string): Observable<GetEnrollmentStatusByIdViewModel> {
    let url_ = this.baseUrl + '/api/enrollments/{id}/enrollmentStatus'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEnrollmentStatus(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEnrollmentStatus(<any>response_)
            } catch (e) {
              return <Observable<GetEnrollmentStatusByIdViewModel>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<GetEnrollmentStatusByIdViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEnrollmentStatus(
    response: HttpResponseBase
  ): Observable<GetEnrollmentStatusByIdViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = GetEnrollmentStatusByIdViewModel.fromJS(resultData200)
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetEnrollmentStatusByIdViewModel>(<any>null)
  }
}


@Injectable({
  providedIn: 'root',
})
export class ScholarshipsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined
  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }
  getScholarships() {
    let url_ = this.baseUrl + '/api/scholarships'
    url_ = url_.replace(/[?&]$/, '')
    let options_: any = {
      observe: 'response',
      responseType: 'json',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }
    return new Promise((resolve) => {
      this.http.get(url_, options_).subscribe((resp: any) => {
        if (resp.status != 200 || !resp.body || typeof (resp.body) !== "object") {
          resolve(false)
          return
        }
        resolve(resp.body)
      }, () => {
        resolve(false)
      })
    })
  }
  getScholarshipRegistrations() {
    let url_ = this.baseUrl + '/api/scholarshipregistration'
    url_ = url_.replace(/[?&]$/, '')
    let options_: any = {
      observe: 'response',
      responseType: 'json',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }
    return new Promise((resolve) => {
      this.http.get(url_, options_).subscribe((resp: any) => {
        if (resp.status != 200 || !resp.body || typeof (resp.body) !== "object") {
          resolve(false)
          return
        }
        resolve(resp.body)
      }, () => {
        resolve(false)
      })
    })
  }
  getScholarshipDetails(id) {
    let url_ = this.baseUrl + '/api/scholarships/' + id
    url_ = url_.replace(/[?&]$/, '')
    let options_: any = {
      observe: 'response',
      responseType: 'json',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }
    return new Promise((resolve) => {
      this.http.get(url_, options_).subscribe((resp: any) => {
        if (resp.status != 200 || !resp.body || typeof (resp.body) !== "object") {
          resolve(false)
          return
        }
        resolve(resp.body)
      }, () => {
        resolve(false)
      })
    })
  }
  registerScholarship(id) {
    let url_ = this.baseUrl + '/api/scholarshipregistration/?scholarshipId=' + id
    url_ = url_.replace(/[?&]$/, '')
    let options_: any = {
      observe: 'response',
      responseType: 'json',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }
    return new Promise((resolve) => {
      this.http.post(url_, {}, options_).subscribe((resp: any) => {
        if (resp.status != 200 || !resp.body || typeof (resp.body) !== "object") {
          resolve(false)
          return
        }
        resolve(resp.body)
      }, () => {
        resolve(false)
      })
    })
  }
}



@Injectable({
  providedIn: 'root',
})
export class EventClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  protected processQuestions(
    response: HttpResponseBase
  ): Observable<ListProgramQuestionByProgramIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListProgramQuestionByProgramIdViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListProgramQuestionByProgramIdViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  questions(id: string): Observable<ListProgramQuestionByProgramIdViewModel[]> {
    let url_ = this.baseUrl + '/api/events/{id}/questions'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processQuestions(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processQuestions(<any>response_)
            } catch (e) {
              return <Observable<ListProgramQuestionByProgramIdViewModel[]>>(
                (<any>_observableThrow(e))
              )
            }
          } else
            return <Observable<ListProgramQuestionByProgramIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  /**
     * @param body (optional)
     * @return Success
     */
  answersPost(eventId: string, body: AnswerForEventsDto[] | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/eventregistrant/withanswers?eventId={id}'
    if (eventId === undefined || eventId === null) throw new Error("The parameter 'eventId' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + eventId))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAnswersPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAnswersPost(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAnswersPost(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  eventsRegistrationGet(): Observable<ListEventsRegistrationModel[]> {
    let url_ = this.baseUrl + '/api/eventregistrant'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEventsRegistrationGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEventsRegistrationGet(<any>response_)
            } catch (e) {
              return <Observable<ListEventsRegistrationModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListEventsRegistrationModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEventsRegistrationGet(response: HttpResponseBase): Observable<ListEventsRegistrationModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListEventsRegistrationModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListEventsRegistrationModel[]>(<any>null)
  }


  /**
   * @return Success
   */
  eventsGet(): Observable<ListEventsViewModel[]> {
    let url_ = this.baseUrl + '/api/events'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEventsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEventsGet(<any>response_)
            } catch (e) {
              return <Observable<ListEventsViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListEventsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEventsGet(response: HttpResponseBase): Observable<ListEventsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListEventsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListEventsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  eventsGetById(id: string): Observable<ListEventsViewModel> {
    let url_ = this.baseUrl + '/api/events/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEventsGetById(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEventsGetById(<any>response_)
            } catch (e) {
              return <Observable<ListEventsViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListEventsViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEventsGetById(response: HttpResponseBase): Observable<ListEventsViewModel> {
    const status = response.status

    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<ListEventsViewModel>(<any>null)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListEventsViewModel>(<any>responseBlob)
  }
}

@Injectable({
  providedIn: 'root',
})
export class EventRegistrantClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @param eventId (optional)
   * @return Success
   */
  eventregistrant(eventId: string | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/eventregistrant?'
    if (eventId === null) throw new Error("The parameter 'eventId' cannot be null.")
    else if (eventId !== undefined) url_ += 'eventId=' + encodeURIComponent('' + eventId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEventregistrant(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEventregistrant(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processEventregistrant(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class LanguageSkillsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  languageSkillsGet(): Observable<ListUserLanguageSkillsViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/language-skills'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLanguageSkillsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLanguageSkillsGet(<any>response_)
            } catch (e) {
              return <Observable<ListUserLanguageSkillsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListUserLanguageSkillsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processLanguageSkillsGet(
    response: HttpResponseBase
  ): Observable<ListUserLanguageSkillsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListUserLanguageSkillsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserLanguageSkillsViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  languageSkillsPost(body: AddLanguageSkillCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/profile/language-skills'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLanguageSkillsPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLanguageSkillsPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processLanguageSkillsPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  languageSkillsPut(id: string, body: EditLanguageSkillCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/language-skills/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLanguageSkillsPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLanguageSkillsPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processLanguageSkillsPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  languageSkillsDelete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/language-skills/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLanguageSkillsDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLanguageSkillsDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processLanguageSkillsDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class MaterialsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  moduleMaterials(moduleId: string): Observable<ListMaterialsByModuleIdViewModel[]> {
    let url_ = this.baseUrl + '/api/materials/module-materials/{moduleId}'
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace('{moduleId}', encodeURIComponent('' + moduleId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processModuleMaterials(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processModuleMaterials(<any>response_)
            } catch (e) {
              return <Observable<ListMaterialsByModuleIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListMaterialsByModuleIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processModuleMaterials(
    response: HttpResponseBase
  ): Observable<ListMaterialsByModuleIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListMaterialsByModuleIdViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  materialsGet(id: string): Observable<GetMaterialByIdViewModel> {
    let url_ = this.baseUrl + '/api/materials/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMaterialsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMaterialsGet(<any>response_)
            } catch (e) {
              return <Observable<GetMaterialByIdViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetMaterialByIdViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processMaterialsGet(response: HttpResponseBase): Observable<GetMaterialByIdViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetMaterialByIdViewModel>(<any>null)
  }

  /**
   * @param materialId (optional)
   * @param moduleId (optional)
   * @param name (optional)
   * @param name_ar (optional)
   * @param location (optional)
   * @param duration (optional)
   * @param order (optional)
   * @param startdate (optional)
   * @param publishdate (optional)
   * @param status (optional)
   * @return Success
   */
  materialsPost(
    materialId: string | undefined,
    moduleId: string | undefined,
    name: string | null | undefined,
    name_ar: string | null | undefined,
    location: string | null | undefined,
    duration: number | undefined,
    order: number | undefined,
    startdate: Date | null | undefined,
    publishdate?: Date | null | undefined,
    status?: MaterialStatuses | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/materials?'
    if (materialId === null) throw new Error("The parameter 'materialId' cannot be null.")
    else if (materialId !== undefined)
      url_ += 'materialId=' + encodeURIComponent('' + materialId) + '&'
    if (moduleId === null) throw new Error("The parameter 'moduleId' cannot be null.")
    else if (moduleId !== undefined) url_ += 'moduleId=' + encodeURIComponent('' + moduleId) + '&'
    if (name !== undefined && name !== null) url_ += 'name=' + encodeURIComponent('' + name) + '&'
    if (name_ar !== undefined && name_ar !== null)
      url_ += 'name_ar=' + encodeURIComponent('' + name_ar) + '&'
    if (location !== undefined && location !== null)
      url_ += 'location=' + encodeURIComponent('' + location) + '&'
    if (duration === null) throw new Error("The parameter 'duration' cannot be null.")
    else if (duration !== undefined) url_ += 'duration=' + encodeURIComponent('' + duration) + '&'
    if (order === null) throw new Error("The parameter 'order' cannot be null.")
    else if (order !== undefined) url_ += 'order=' + encodeURIComponent('' + order) + '&'
    if (startdate !== undefined && startdate !== null)
      url_ += 'startdate=' + encodeURIComponent(startdate ? '' + startdate.toJSON() : '') + '&'
    if (publishdate !== undefined && publishdate !== null)
      url_ +=
        'publishdate=' + encodeURIComponent(publishdate ? '' + publishdate.toJSON() : '') + '&'
    if (status === null) throw new Error("The parameter 'status' cannot be null.")
    else if (status !== undefined) url_ += 'status=' + encodeURIComponent('' + status) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMaterialsPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMaterialsPost(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processMaterialsPost(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  cohortMaterials(moduleId: string): Observable<ListMaterialsByCohortModuleIdViewModel[]> {
    let url_ = this.baseUrl + '/api/materials/cohort-materials/{moduleId}'
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace('{moduleId}', encodeURIComponent('' + moduleId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCohortMaterials(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCohortMaterials(<any>response_)
            } catch (e) {
              return <Observable<ListMaterialsByCohortModuleIdViewModel[]>>(
                (<any>_observableThrow(e))
              )
            }
          } else
            return <Observable<ListMaterialsByCohortModuleIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processCohortMaterials(
    response: HttpResponseBase
  ): Observable<ListMaterialsByCohortModuleIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListMaterialsByCohortModuleIdViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class MembershipsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  membershipsGet(): Observable<ListUserMembershipsViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/memberships'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMembershipsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMembershipsGet(<any>response_)
            } catch (e) {
              return <Observable<ListUserMembershipsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListUserMembershipsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processMembershipsGet(
    response: HttpResponseBase
  ): Observable<ListUserMembershipsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListUserMembershipsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserMembershipsViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  membershipsPost(body: AddMembershipCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/profile/memberships'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMembershipsPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMembershipsPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processMembershipsPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  membershipsPut(id: string, body: EditMembershipCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/memberships/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMembershipsPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMembershipsPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processMembershipsPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  membershipsDelete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/memberships/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMembershipsDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMembershipsDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processMembershipsDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class MentorsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  mentor(id: string): Observable<Mentor> {
    let url_ = this.baseUrl + '/api/mentor/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMentor(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMentor(<any>response_)
            } catch (e) {
              return <Observable<Mentor>>(<any>_observableThrow(e))
            }
          } else return <Observable<Mentor>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processMentor(response: HttpResponseBase): Observable<Mentor> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          const result200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<Mentor>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class MetadataClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  industries(): Observable<ListIndustriesViewModel[]> {
    let url_ = this.baseUrl + '/api/metadata/industries'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIndustries(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIndustries(<any>response_)
            } catch (e) {
              return <Observable<ListIndustriesViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListIndustriesViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processIndustries(response: HttpResponseBase): Observable<ListIndustriesViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListIndustriesViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListIndustriesViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  sectors(): Observable<ListSectorsViewModel[]> {
    let url_ = this.baseUrl + '/api/metadata/sectors'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSectors(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSectors(<any>response_)
            } catch (e) {
              return <Observable<ListSectorsViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListSectorsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSectors(response: HttpResponseBase): Observable<ListSectorsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListSectorsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListSectorsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  languages(): Observable<ListLanguagesViewModel[]> {
    let url_ = this.baseUrl + '/api/metadata/languages'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLanguages(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLanguages(<any>response_)
            } catch (e) {
              return <Observable<ListLanguagesViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListLanguagesViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processLanguages(response: HttpResponseBase): Observable<ListLanguagesViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListLanguagesViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListLanguagesViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ModulesClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  programModules(programId: string): Observable<ListModulesByProgramIdViewModel[]> {
    let url_ = this.baseUrl + '/api/modules/program-modules/{programId}'
    if (programId === undefined || programId === null)
      throw new Error("The parameter 'programId' must be defined.")
    url_ = url_.replace('{programId}', encodeURIComponent('' + programId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProgramModules(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProgramModules(<any>response_)
            } catch (e) {
              return <Observable<ListModulesByProgramIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListModulesByProgramIdViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProgramModules(
    response: HttpResponseBase
  ): Observable<ListModulesByProgramIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListModulesByProgramIdViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListModulesByProgramIdViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  eliteClubModules(eliteClubId: string): Observable<ListModulesByEliteClubIdViewModel[]> {
    let url_ = this.baseUrl + '/api/modules/elite-club-modules/{eliteClubId}'
    if (eliteClubId === undefined || eliteClubId === null)
      throw new Error("The parameter 'eliteClubId' must be defined.")
    url_ = url_.replace('{eliteClubId}', encodeURIComponent('' + eliteClubId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEliteClubModules(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEliteClubModules(<any>response_)
            } catch (e) {
              return <Observable<ListModulesByEliteClubIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListModulesByEliteClubIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processEliteClubModules(
    response: HttpResponseBase
  ): Observable<ListModulesByEliteClubIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListModulesByEliteClubIdViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListModulesByEliteClubIdViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  applicantProfile(id: string): Observable<GetApplicantProfileViewModel> {
    let url_ = this.baseUrl + '/api/modules/applicant-profile/{Id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{Id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApplicantProfile(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApplicantProfile(<any>response_)
            } catch (e) {
              return <Observable<GetApplicantProfileViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetApplicantProfileViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processApplicantProfile(
    response: HttpResponseBase
  ): Observable<GetApplicantProfileViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetApplicantProfileViewModel>(<any>null)
  }

  /**
   * @return Success
   */
  universityProfile(moduleId: string): Observable<GetUniversityProfileViewModel> {
    let url_ = this.baseUrl + '/api/modules/university-profile/{moduleId}'
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace('{moduleId}', encodeURIComponent('' + moduleId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUniversityProfile(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUniversityProfile(<any>response_)
            } catch (e) {
              return <Observable<GetUniversityProfileViewModel>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<GetUniversityProfileViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUniversityProfile(
    response: HttpResponseBase
  ): Observable<GetUniversityProfileViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetUniversityProfileViewModel>(<any>null)
  }

  /**
   * @return Success
   */
  modules(id: string): Observable<GetModuleByIdViewModel> {
    let url_ = this.baseUrl + '/api/modules/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processModules(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processModules(<any>response_)
            } catch (e) {
              return <Observable<GetModuleByIdViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetModuleByIdViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processModules(response: HttpResponseBase): Observable<GetModuleByIdViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = GetModuleByIdViewModel.fromJS(resultData200)
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetModuleByIdViewModel>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  moduleOverview(body: UpdateOverviewCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/modules/module-overview'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processModuleOverview(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processModuleOverview(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processModuleOverview(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @return Success
   */
  instructorProfile(moduleId: string): Observable<GetInstructorProfileViewModel> {
    let url_ = this.baseUrl + '/api/modules/instructor-profile/{moduleId}'
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace('{moduleId}', encodeURIComponent('' + moduleId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInstructorProfile(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInstructorProfile(<any>response_)
            } catch (e) {
              return <Observable<GetInstructorProfileViewModel>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<GetInstructorProfileViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processInstructorProfile(
    response: HttpResponseBase
  ): Observable<GetInstructorProfileViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = GetInstructorProfileViewModel.fromJS(resultData200)
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetInstructorProfileViewModel>(<any>null)
  }

  /**
   * @return Success
   */
  moduleApplicants(moduleId: string): Observable<ListModuleApplicantsViewModel[]> {
    let url_ = this.baseUrl + '/api/modules/module-applicants/{moduleId}'
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace('{moduleId}', encodeURIComponent('' + moduleId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processModuleApplicants(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processModuleApplicants(<any>response_)
            } catch (e) {
              return <Observable<ListModuleApplicantsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListModuleApplicantsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processModuleApplicants(
    response: HttpResponseBase
  ): Observable<ListModuleApplicantsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) {
              result200!.push(item)
            }
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListModuleApplicantsViewModel[]>(<any>null)
  }

  cohortModules(cohortId: string): Observable<ListModulesByCohortIdViewModel[]> {
    let url_ = this.baseUrl + '/api/modules/cohort-modules/{cohortId}'
    if (cohortId === undefined || cohortId === null)
      throw new Error("The parameter 'cohortId' must be defined.")
    url_ = url_.replace('{cohortId}', encodeURIComponent('' + cohortId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCohortModules(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCohortModules(<any>response_)
            } catch (e) {
              return <Observable<ListModulesByCohortIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListModulesByCohortIdViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processCohortModules(
    response: HttpResponseBase
  ): Observable<ListModulesByCohortIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListModulesByCohortIdViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProjectIdeasClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  projectIdeasGet(): Observable<ListProjectIdeasViewModel[]> {
    let url_ = this.baseUrl + '/api/project-ideas'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProjectIdeasGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProjectIdeasGet(<any>response_)
            } catch (e) {
              return <Observable<ListProjectIdeasViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListProjectIdeasViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProjectIdeasGet(
    response: HttpResponseBase
  ): Observable<ListProjectIdeasViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListProjectIdeasViewModel[]>(<any>null)
  }

  /**
   * @param file (optional)
   * @param projectIdeaId (optional)
   * @param description (optional)
   * @param name (optional)
   * @param body (optional)
   * @param benchmark (optional)
   * @param projectIdeaStatus (optional)
   * @param budget (optional)
   * @param sectorId (optional)
   * @param otherSector (optional)
   * @return Success
   */
  projectIdeasPost(
    file: FileParameter | null | undefined,
    projectIdeaId: string | null | undefined,
    description: string | null | undefined,
    name: string | null | undefined,
    body: string | null | undefined,
    benchmark: string | null | undefined,
    projectIdeaStatus: number | undefined,
    budget: number | undefined,
    sectorId: string | null | undefined,
    otherSector: string | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/project-ideas'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')
    if (projectIdeaId !== null && projectIdeaId !== undefined)
      content_.append('projectIdeaId', projectIdeaId.toString())
    if (description !== null && description !== undefined)
      content_.append('description', description.toString())
    if (name !== null && name !== undefined) content_.append('name', name.toString())
    if (body !== null && body !== undefined) content_.append('body', body.toString())
    if (benchmark !== null && benchmark !== undefined)
      content_.append('benchmark', benchmark.toString())
    if (projectIdeaStatus === null || projectIdeaStatus === undefined)
      throw new Error("The parameter 'projectIdeaStatus' cannot be null.")
    else content_.append('projectIdeaStatus', projectIdeaStatus.toString())
    if (budget === null || budget === undefined)
      throw new Error("The parameter 'budget' cannot be null.")
    else content_.append('budget', budget.toString())
    if (sectorId !== null && sectorId !== undefined)
      content_.append('sectorId', sectorId.toString())
    if (otherSector !== null && otherSector !== undefined)
      content_.append('otherSector', otherSector.toString())

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProjectIdeasPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProjectIdeasPost(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProjectIdeasPost(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  userProjectIdeas(): Observable<ListUserProjectIdeasViewModel[]> {
    let url_ = this.baseUrl + '/api/project-ideas/user-project-ideas'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserProjectIdeas(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserProjectIdeas(<any>response_)
            } catch (e) {
              return <Observable<ListUserProjectIdeasViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListUserProjectIdeasViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUserProjectIdeas(
    response: HttpResponseBase
  ): Observable<ListUserProjectIdeasViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserProjectIdeasViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  search(text: string | null): Observable<SearchProjectIdeasViewModel[]> {
    let url_ = this.baseUrl + '/api/project-ideas/search/{text}'
    if (text === undefined || text === null)
      throw new Error("The parameter 'text' must be defined.")
    url_ = url_.replace('{text}', encodeURIComponent('' + text))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSearch(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSearch(<any>response_)
            } catch (e) {
              return <Observable<SearchProjectIdeasViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<SearchProjectIdeasViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSearch(response: HttpResponseBase): Observable<SearchProjectIdeasViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<SearchProjectIdeasViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  projectIdeasGetById(id: string): Observable<any | ListProjectIdeasViewModel[]> {
    let url_ = this.baseUrl + '/api/project-ideas/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProjectIdeasGetById(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProjectIdeasGetById(<any>response_)
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e))
            }
          } else return <Observable<any>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProjectIdeasGetById(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (resultData200) {
            return _observableOf(resultData200)
          }
        })
      )
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<any>(<any>null)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<any>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class NewsFeedsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  moduleNewsfeeds(moduleid: string): Observable<ListNewsFeedsViewModel[]> {
    let url_ = this.baseUrl + '/api/newsfeeds/module-newsfeeds/{moduleid}'
    if (moduleid === undefined || moduleid === null)
      throw new Error("The parameter 'moduleid' must be defined.")
    url_ = url_.replace('{moduleid}', encodeURIComponent('' + moduleid))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processModuleNewsfeeds(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processModuleNewsfeeds(<any>response_)
            } catch (e) {
              return <Observable<ListNewsFeedsViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListNewsFeedsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processModuleNewsfeeds(
    response: HttpResponseBase
  ): Observable<ListNewsFeedsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListNewsFeedsViewModel.fromJS(item))
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListNewsFeedsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  instructorOrAdminNewsfeeds(moduleid: string): Observable<ListUserNewsFeedsViewModel[]> {
    let url_ = this.baseUrl + '/api/newsfeeds/instructorOrAdmin-newsfeeds/{moduleid}'
    if (moduleid === undefined || moduleid === null)
      throw new Error("The parameter 'moduleid' must be defined.")
    url_ = url_.replace('{moduleid}', encodeURIComponent('' + moduleid))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInstructorOrAdminNewsfeeds(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInstructorOrAdminNewsfeeds(<any>response_)
            } catch (e) {
              return <Observable<ListUserNewsFeedsViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListUserNewsFeedsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processInstructorOrAdminNewsfeeds(
    response: HttpResponseBase
  ): Observable<ListUserNewsFeedsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListUserNewsFeedsViewModel.fromJS(item))
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserNewsFeedsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  newsfeedsGet(id: string): Observable<any> {
    let url_ = this.baseUrl + '/api/newsfeeds/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNewsfeedsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNewsfeedsGet(<any>response_)
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e))
            }
          } else return <Observable<any>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processNewsfeedsGet(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 204 || status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<any>(<any>JSON.parse(_responseText))
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<any>(<any>null)
  }

  /**
   * @return Success
   */
  newsfeedsDelete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/newsfeeds/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNewsfeedsDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNewsfeedsDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processNewsfeedsDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param file (optional)
   * @param moduleid (optional)
   * @param newsfeedid (optional)
   * @param name (optional)
   * @param duration (optional)
   * @param order (optional)
   * @param type (optional)
   * @param text (optional)
   * @param url (optional)
   * @param status (optional)
   * @param notifyusers (optional)
   * @param meetingstartdate (optional)
   * @param publishdate (optional)
   * @param expirydate (optional)
   * @return Success
   */
  newsfeedsPost(
    file: FileParameter | null | undefined,
    moduleid: string | undefined,
    newsfeedid: string | null | undefined,
    name: string | null | undefined,
    duration: number | undefined,
    order: number | undefined,
    type: number | undefined,
    text: string | null | undefined,
    url: string | null | undefined,
    status: number | undefined,
    notifyusers: boolean | undefined,
    meetingstartdate: Date | null | undefined,
    publishdate: Date | null | undefined,
    expirydate: Date | null | undefined
  ): Observable<any> {
    let url_ = this.baseUrl + '/api/newsfeeds'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')
    if (moduleid === null || moduleid === undefined)
      throw new Error("The parameter 'moduleid' cannot be null.")
    else content_.append('moduleid', moduleid.toString())
    if (newsfeedid !== null && newsfeedid !== undefined)
      content_.append('newsfeedid', newsfeedid.toString())
    if (name !== null && name !== undefined) content_.append('name', name.toString())
    if (duration === null || duration === undefined)
      throw new Error("The parameter 'duration' cannot be null.")
    else content_.append('duration', duration.toString())
    if (order === null || order === undefined)
      throw new Error("The parameter 'order' cannot be null.")
    else content_.append('order', order.toString())
    if (type === null || type === undefined) throw new Error("The parameter 'type' cannot be null.")
    else content_.append('type', type.toString())
    if (text !== null && text !== undefined) content_.append('text', text.toString())
    if (url !== null && url !== undefined) content_.append('url', url.toString())
    if (status === null || status === undefined)
      throw new Error("The parameter 'status' cannot be null.")
    else content_.append('status', status.toString())
    if (notifyusers === null || notifyusers === undefined)
      throw new Error("The parameter 'notifyusers' cannot be null.")
    else content_.append('notifyusers', notifyusers.toString())
    if (meetingstartdate !== null && meetingstartdate !== undefined)
      content_.append('meetingstartdate', meetingstartdate.toJSON())
    if (publishdate !== null && publishdate !== undefined)
      content_.append('publishdate', publishdate.toJSON())
    if (expirydate !== null && expirydate !== undefined)
      content_.append('expirydate', expirydate.toJSON())

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http.request('post', url_, options_)
  }
}

export class ListCommentsByNewsFeedIdViewModel implements IListCommentsByNewsFeedIdViewModel {
  id?: string
  contactId?: string
  contactName?: string | undefined
  newsFeedId?: string | undefined
  action?: number
  actionDate?: Date | undefined
  comment?: string | undefined

  constructor(data?: IListCommentsByNewsFeedIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.contactId = _data['contactId']
      this.contactName = _data['contactName']
      this.newsFeedId = _data['newsFeedId']
      this.action = _data['action']
      this.actionDate = _data['actionDate']
        ? new Date(_data['actionDate'].toString())
        : <any>undefined
      this.comment = _data['comment']
    }
  }

  static fromJS(data: any): ListCommentsByNewsFeedIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListCommentsByNewsFeedIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['contactId'] = this.contactId
    data['contactName'] = this.contactName
    data['newsFeedId'] = this.newsFeedId
    data['action'] = this.action
    data['actionDate'] = this.actionDate ? this.actionDate.toISOString() : <any>undefined
    data['comment'] = this.comment
    return data
  }
}

export interface IListCommentsByNewsFeedIdViewModel {
  id?: string
  contactId?: string
  contactName?: string | undefined
  newsFeedId?: string | undefined
  action?: number
  actionDate?: Date | undefined
  comment?: string | undefined
}

@Injectable({
  providedIn: 'root',
})
export class PanHistoriesClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @param articleId (optional)
   * @param postId (optional)
   * @param newsFeedId (optional)
   * @param like (optional)
   * @return Success
   */
  like(
    articleId: string | undefined,
    postId: string | undefined,
    newsFeedId: string | undefined,
    like: boolean | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + '/api/pan-history/like?'
    if (articleId === null) throw new Error("The parameter 'articleId' cannot be null.")
    else if (articleId !== undefined)
      url_ += 'ArticleId=' + encodeURIComponent('' + articleId) + '&'
    if (postId === null) throw new Error("The parameter 'postId' cannot be null.")
    else if (postId !== undefined) url_ += 'PostId=' + encodeURIComponent('' + postId) + '&'
    if (newsFeedId === null) throw new Error("The parameter 'newsFeedId' cannot be null.")
    else if (newsFeedId !== undefined)
      url_ += 'NewsFeedId=' + encodeURIComponent('' + newsFeedId) + '&'
    if (like === null) throw new Error("The parameter 'like' cannot be null.")
    else if (like !== undefined) url_ += 'Like=' + encodeURIComponent('' + like) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLike(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLike(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processLike(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param postId (optional)
   * @param newsfeedId (optional)
   * @param comment (optional)
   * @return Success
   */
  comment(
    postId: string | undefined,
    newsfeedId: string | undefined,
    comment: string | null | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + '/api/pan-history/comment?'
    if (postId === null) throw new Error("The parameter 'postId' cannot be null.")
    else if (postId !== undefined) url_ += 'postId=' + encodeURIComponent('' + postId) + '&'
    if (newsfeedId === null) throw new Error("The parameter 'newsfeedId' cannot be null.")
    else if (newsfeedId !== undefined)
      url_ += 'newsfeedId=' + encodeURIComponent('' + newsfeedId) + '&'
    if (comment !== undefined && comment !== null)
      url_ += 'comment=' + encodeURIComponent('' + comment) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processComment(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processComment(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processComment(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @return Success
   */
  postComments(id: string): Observable<ListCommentsByPostIdViewModel[]> {
    let url_ = this.baseUrl + '/api/pan-history/post-comments/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPostComments(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPostComments(<any>response_)
            } catch (e) {
              return <Observable<ListCommentsByPostIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListCommentsByPostIdViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processPostComments(
    response: HttpResponseBase
  ): Observable<ListCommentsByPostIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListCommentsByPostIdViewModel.fromJS(item))
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListCommentsByPostIdViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  newsfeedComments(id: string): Observable<ListCommentsByNewsFeedIdViewModel[]> {
    let url_ = this.baseUrl + '/api/pan-history/newsfeed-comments/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNewsfeedComments(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNewsfeedComments(<any>response_)
            } catch (e) {
              return <Observable<ListCommentsByNewsFeedIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListCommentsByNewsFeedIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processNewsfeedComments(
    response: HttpResponseBase
  ): Observable<ListCommentsByNewsFeedIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListCommentsByNewsFeedIdViewModel.fromJS(item))
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListCommentsByNewsFeedIdViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProfessionalExperiencesClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  professionalExperiencesGet(): Observable<ListUserProfessionalExperiencesViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/professional-experiences'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProfessionalExperiencesGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProfessionalExperiencesGet(<any>response_)
            } catch (e) {
              return <Observable<ListUserProfessionalExperiencesViewModel[]>>(
                (<any>_observableThrow(e))
              )
            }
          } else
            return <Observable<ListUserProfessionalExperiencesViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processProfessionalExperiencesGet(
    response: HttpResponseBase
  ): Observable<ListUserProfessionalExperiencesViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListUserProfessionalExperiencesViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserProfessionalExperiencesViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  professionalExperiencesPost(
    body: AddProfessionalExperienceCommand | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + '/api/profile/professional-experiences'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProfessionalExperiencesPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProfessionalExperiencesPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProfessionalExperiencesPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  professionalExperiencesPut(
    id: string,
    body: EditProfessionalExperienceCommand | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/professional-experiences/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }
    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProfessionalExperiencesPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProfessionalExperiencesPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProfessionalExperiencesPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  professionalExperiencesDelete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/professional-experiences/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProfessionalExperiencesDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProfessionalExperiencesDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProfessionalExperiencesDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProfileClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  profile(): Observable<GetUserProfileViewModel> {
    let url_ = this.baseUrl + '/api/profile'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProfile(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProfile(<any>response_)
            } catch (e) {
              return <Observable<GetUserProfileViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetUserProfileViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProfile(response: HttpResponseBase): Observable<GetUserProfileViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = GetUserProfileViewModel.fromJS(resultData200)
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetUserProfileViewModel>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  isActiveMember(body: SetIsActiveMemberCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/is-active-member'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsActiveMember(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsActiveMember(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processIsActiveMember(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  profileCompletion(): Observable<GetUserProfileCompletionViewModel> {
    let url_ = this.baseUrl + '/api/profile/profile-completion'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProfileCompletion(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProfileCompletion(<any>response_)
            } catch (e) {
              return <Observable<GetUserProfileCompletionViewModel>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<GetUserProfileCompletionViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProfileCompletion(
    response: HttpResponseBase
  ): Observable<GetUserProfileCompletionViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = GetUserProfileCompletionViewModel.fromJS(resultData200)
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetUserProfileCompletionViewModel>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  generalInformation(body: EditUserGeneralInformationCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/general-information'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGeneralInformation(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGeneralInformation(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processGeneralInformation(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  resetProfileIsOutDated(): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/reset-last-update'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify({})

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return _observableOf<void>(<any>null)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return _observableOf<void>(<any>null)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }


  /**
   * @param body (optional)
   * @return Success
   */
  contactDetails(body: EditUserContactDetailsCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/contact-details'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processContactDetails(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processContactDetails(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processContactDetails(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  identityDetails(body: EditUserIdentityDetailsCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/identity-details'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIdentityDetails(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIdentityDetails(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processIdentityDetails(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    }
    else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  learningPreferencesGet(): Observable<GetUserLearningPreferencesViewModel> {
    let url_ = this.baseUrl + '/api/profile/learning-preferences'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLearningPreferencesGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLearningPreferencesGet(<any>response_)
            } catch (e) {
              return <Observable<GetUserLearningPreferencesViewModel>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<GetUserLearningPreferencesViewModel>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processLearningPreferencesGet(
    response: HttpResponseBase
  ): Observable<GetUserLearningPreferencesViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = GetUserLearningPreferencesViewModel.fromJS(resultData200)
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetUserLearningPreferencesViewModel>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  learningPreferencesPost(body: EditUserLearningPreferencesCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/learning-preferences'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLearningPreferencesPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLearningPreferencesPost(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processLearningPreferencesPost(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param file (optional)
   * @return Success
   */
  profilePicturePost(file: FileParameter | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/profile-picture'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProfilePicturePost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProfilePicturePost(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProfilePicturePost(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  profilePictureDelete(): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/profile-picture'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProfilePictureDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProfilePictureDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProfilePictureDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param about (optional)
   * @return Success
   */
  aboutInstructor(about: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/about-instructor?'
    if (about !== undefined && about !== null)
      url_ += 'about=' + encodeURIComponent('' + about) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAboutInstructor(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAboutInstructor(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAboutInstructor(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param aboutuniversity (optional)
   * @return Success
   */
  aboutUniversity(aboutuniversity: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/about-university?'
    if (aboutuniversity !== undefined && aboutuniversity !== null)
      url_ += 'aboutuniversity=' + encodeURIComponent('' + aboutuniversity) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAboutUniversity(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAboutUniversity(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAboutUniversity(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  directmanagerApplicants(): Observable<ListDirectManagerApplicantsViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/directmanager-applicants'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDirectmanagerApplicants(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDirectmanagerApplicants(<any>response_)
            } catch (e) {
              return <Observable<ListDirectManagerApplicantsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListDirectManagerApplicantsViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processDirectmanagerApplicants(
    response: HttpResponseBase
  ): Observable<ListDirectManagerApplicantsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListDirectManagerApplicantsViewModel[]>(<any>null)
  }

  /**
   * @param programId (optional)
   * @param sectorId (optional)
   * @param year (optional)
   * @return Success
   */
  searchAlumniCriteria(
    programId: string | null | undefined,
    sectorId: string | null | undefined,
    year: number | null | undefined
  ): Observable<SearchAlumniViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/search-alumni-criteria?'
    if (programId !== undefined && programId !== null)
      url_ += 'programId=' + encodeURIComponent('' + programId) + '&'
    if (sectorId !== undefined && sectorId !== null)
      url_ += 'sectorId=' + encodeURIComponent('' + sectorId) + '&'
    if (year !== undefined && year !== null) url_ += 'year=' + encodeURIComponent('' + year) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSearchAlumniCriteria(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSearchAlumniCriteria(<any>response_)
            } catch (e) {
              return <Observable<SearchAlumniViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<SearchAlumniViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSearchAlumniCriteria(
    response: HttpResponseBase
  ): Observable<SearchAlumniViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<SearchAlumniViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  usersForChat(): Observable<ListAlumniUsersForChatViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/users-for-chat'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUsersForChat(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUsersForChat(<any>response_)
            } catch (e) {
              return <Observable<ListAlumniUsersForChatViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListAlumniUsersForChatViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUsersForChat(
    response: HttpResponseBase
  ): Observable<ListAlumniUsersForChatViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListAlumniUsersForChatViewModel[]>(<any>null)
  }

  /**
   * @param disclaimerType (optional)
   * @return Success
   */
  userDisclaimerGet(disclaimerType: number | undefined): Observable<GetUserDisclaimerViewModel> {
    let url_ = this.baseUrl + '/api/profile/user-disclaimer?'
    if (disclaimerType === null) throw new Error("The parameter 'disclaimerType' cannot be null.")
    else if (disclaimerType !== undefined)
      url_ += 'disclaimerType=' + encodeURIComponent('' + disclaimerType) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserDisclaimerGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserDisclaimerGet(<any>response_)
            } catch (e) {
              return <Observable<GetUserDisclaimerViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetUserDisclaimerViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUserDisclaimerGet(
    response: HttpResponseBase
  ): Observable<GetUserDisclaimerViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(GetUserDisclaimerViewModel.fromJS(item))
          } else {
            result200 = <any>resultData200
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetUserDisclaimerViewModel>(<any>null)
  }

  /**
   * @param disclaimerType (optional)
   * @return Success
   */
  userDisclaimerPut(disclaimerType: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/user-disclaimer?'
    if (disclaimerType === null) throw new Error("The parameter 'disclaimerType' cannot be null.")
    else if (disclaimerType !== undefined)
      url_ += 'disclaimerType=' + encodeURIComponent('' + disclaimerType) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserDisclaimerPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserDisclaimerPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUserDisclaimerPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class SpecialProjectsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  userSpecialProjects(): Observable<ListUserSpecialProjectsViewModel[]> {
    let url_ = this.baseUrl + '/api/special-projects/user-special-projects'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserSpecialProjects(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserSpecialProjects(<any>response_)
            } catch (e) {
              return <Observable<ListUserSpecialProjectsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListUserSpecialProjectsViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processUserSpecialProjects(
    response: HttpResponseBase
  ): Observable<ListUserSpecialProjectsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserSpecialProjectsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  specialProjectsGet(id: string): Observable<any> {
    let url_ = this.baseUrl + '/api/special-projects/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSpecialProjectsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSpecialProjectsGet(<any>response_)
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e))
            }
          } else return <Observable<any>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSpecialProjectsGet(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          return _observableOf(resultData200)
        })
      )
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<any>(<any>null)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<any>(<any>null)
  }

  /**
   * @param file (optional)
   * @param specialProjectId (optional)
   * @param description (optional)
   * @param benchmark (optional)
   * @param name (optional)
   * @param body (optional)
   * @param specialProjectStatus (optional)
   * @param specialProjectTopicId (optional)
   * @param budget (optional)
   * @param sectorId (optional)
   * @param otherSector (optional)
   * @return Success
   */
  specialProjectsPost(
    file: FileParameter | null | undefined,
    specialProjectId: string | null | undefined,
    description: string | null | undefined,
    benchmark: string | null | undefined,
    name: string | null | undefined,
    body: string | null | undefined,
    specialProjectStatus: number | undefined,
    specialProjectTopicId: string | null | undefined,
    budget: number | undefined,
    sectorId: string | null | undefined,
    otherSector: string | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/special-projects'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')
    if (specialProjectId !== null && specialProjectId !== undefined)
      content_.append('specialProjectId', specialProjectId.toString())
    if (description !== null && description !== undefined)
      content_.append('description', description.toString())
    if (benchmark !== null && benchmark !== undefined)
      content_.append('benchmark', benchmark.toString())
    if (name !== null && name !== undefined) content_.append('name', name.toString())
    if (body !== null && body !== undefined) content_.append('body', body.toString())
    if (specialProjectStatus === null || specialProjectStatus === undefined)
      throw new Error("The parameter 'specialProjectStatus' cannot be null.")
    else content_.append('specialProjectStatus', specialProjectStatus.toString())
    if (specialProjectTopicId !== null && specialProjectTopicId !== undefined)
      content_.append('specialProjectTopicId', specialProjectTopicId.toString())
    if (budget === null || budget === undefined)
      throw new Error("The parameter 'budget' cannot be null.")
    else content_.append('budget', budget.toString())
    if (sectorId !== null && sectorId !== undefined)
      content_.append('sectorId', sectorId.toString())
    if (otherSector !== null && otherSector !== undefined)
      content_.append('otherSector', otherSector.toString())

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSpecialProjectsPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSpecialProjectsPost(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSpecialProjectsPost(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class SpecialProjectTopicsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  specialProjectTopics(): Observable<ListSpecialProjectTopicsViewModel[]> {
    let url_ = this.baseUrl + '/api/special-project-topics'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSpecialProjectTopics(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSpecialProjectTopics(<any>response_)
            } catch (e) {
              return <Observable<ListSpecialProjectTopicsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListSpecialProjectTopicsViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processSpecialProjectTopics(
    response: HttpResponseBase
  ): Observable<ListSpecialProjectTopicsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListSpecialProjectTopicsViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class SurveysClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  suveys(): Observable<ListUserSurveysUrlViewModel[]> {
    let url_ = this.baseUrl + '/api/suveys'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSuveys(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSuveys(<any>response_)
            } catch (e) {
              return <Observable<ListUserSurveysUrlViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListUserSurveysUrlViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSuveys(response: HttpResponseBase): Observable<ListUserSurveysUrlViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListUserSurveysUrlViewModel.fromJS(item))
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserSurveysUrlViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  programSurveys(): Observable<ListSurveysByProgramIdViewModel[]> {
    let url_ = this.baseUrl + '/api/suveys/program-surveys'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProgramSurveys(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProgramSurveys(<any>response_)
            } catch (e) {
              return <Observable<ListSurveysByProgramIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListSurveysByProgramIdViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProgramSurveys(
    response: HttpResponseBase
  ): Observable<ListSurveysByProgramIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListSurveysByProgramIdViewModel.fromJS(item))
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListSurveysByProgramIdViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class TopicsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  topics(programId: string): Observable<ListTopicsByProgramIdViewModel[]> {
    let url_ = this.baseUrl + '/api/topics/{programId}'
    if (programId === undefined || programId === null)
      throw new Error("The parameter 'programId' must be defined.")
    url_ = url_.replace('{programId}', encodeURIComponent('' + programId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTopics(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTopics(<any>response_)
            } catch (e) {
              return <Observable<ListTopicsByProgramIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListTopicsByProgramIdViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processTopics(
    response: HttpResponseBase
  ): Observable<ListTopicsByProgramIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListTopicsByProgramIdViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class UniversitiesClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  universityGet(id: string): Observable<any> {
    let url_ = this.baseUrl + '/api/university/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUniversityGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUniversityGet(<any>response_)
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e))
            }
          } else return <Observable<any>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUniversityGet(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultData200 = JSON.parse(_responseText, this.jsonParseReviver)
          return _observableOf(resultData200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<any>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  universityPost(body: UpdateUniversityCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/university'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUniversityPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUniversityPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUniversityPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class UniversityTeamMembersClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  instructor(): Observable<ListTeamMembersViewModel[]> {
    let url_ = this.baseUrl + '/api/university-team-member/instructor'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInstructor(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInstructor(<any>response_)
            } catch (e) {
              return <Observable<ListTeamMembersViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListTeamMembersViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processInstructor(response: HttpResponseBase): Observable<ListTeamMembersViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListTeamMembersViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  applicant(moduleId: string): Observable<ListTeamMembersByModuleIdViewModel[]> {
    let url_ = this.baseUrl + '/api/university-team-member/applicant/{moduleId}'
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace('{moduleId}', encodeURIComponent('' + moduleId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApplicant(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApplicant(<any>response_)
            } catch (e) {
              return <Observable<ListTeamMembersByModuleIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListTeamMembersByModuleIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processApplicant(
    response: HttpResponseBase
  ): Observable<ListTeamMembersByModuleIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListTeamMembersByModuleIdViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  universityTeamMemberGet(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/university-team-member/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUniversityTeamMemberGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUniversityTeamMemberGet(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUniversityTeamMemberGet(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>JSON.parse(_responseText, this.jsonParseReviver))
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param firstname (optional)
   * @param lastname (optional)
   * @param aboutmember (optional)
   * @param email (optional)
   * @param nationality (optional)
   * @param residencecountry (optional)
   * @param jobposition (optional)
   * @param education (optional)
   * @param file (optional)
   * @return Success
   */
  universityTeamMemberPost(
    firstname: string | null | undefined,
    lastname: string | null | undefined,
    aboutmember: string | null | undefined,
    email: string | null | undefined,
    nationality: string | null | undefined,
    residencecountry: string | null | undefined,
    jobposition: string | null | undefined,
    education: string | null | undefined,
    linkedin: string | null | undefined,
    file: FileParameter | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/university-team-member?'
    if (firstname !== undefined && firstname !== null)
      url_ += 'firstname=' + encodeURIComponent('' + firstname) + '&'
    if (lastname !== undefined && lastname !== null)
      url_ += 'lastname=' + encodeURIComponent('' + lastname) + '&'
    if (aboutmember !== undefined && aboutmember !== null)
      url_ += 'aboutmember=' + encodeURIComponent('' + aboutmember) + '&'
    if (email !== undefined && email !== null)
      url_ += 'email=' + encodeURIComponent('' + email) + '&'
    if (nationality !== undefined && nationality !== null)
      url_ += 'nationality=' + encodeURIComponent('' + nationality) + '&'
    if (residencecountry !== undefined && residencecountry !== null)
      url_ += 'residencecountry=' + encodeURIComponent('' + residencecountry) + '&'
    if (jobposition !== undefined && jobposition !== null)
      url_ += 'jobposition=' + encodeURIComponent('' + jobposition) + '&'
    if (education !== undefined && education !== null)
      url_ += 'education=' + encodeURIComponent('' + education) + '&'
    if (linkedin !== undefined && linkedin !== null)
      url_ += 'linkedin=' + encodeURIComponent('' + linkedin) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUniversityTeamMemberPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUniversityTeamMemberPost(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUniversityTeamMemberPost(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param teamMemberId (optional)
   * @param firstname (optional)
   * @param lastname (optional)
   * @param aboutmember (optional)
   * @param email (optional)
   * @param nationality (optional)
   * @param residencecountry (optional)
   * @param jobposition (optional)
   * @param education (optional)
   * @param linkedin (optional)
   * @param file (optional)
   * @return Success
   */
  universityTeamMemberPut(
    teamMemberId: string | undefined,
    firstname: string | null | undefined,
    lastname: string | null | undefined,
    aboutmember: string | null | undefined,
    email: string | null | undefined,
    nationality: string | null | undefined,
    residencecountry: string | null | undefined,
    jobposition: string | null | undefined,
    education: string | null | undefined,
    linkedin: string | null | undefined,
    file: FileParameter | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/university-team-member?'
    if (teamMemberId === null) throw new Error("The parameter 'teamMemberId' cannot be null.")
    else if (teamMemberId !== undefined)
      url_ += 'teamMemberId=' + encodeURIComponent('' + teamMemberId) + '&'
    if (firstname !== undefined && firstname !== null)
      url_ += 'firstname=' + encodeURIComponent('' + firstname) + '&'
    if (lastname !== undefined && lastname !== null)
      url_ += 'lastname=' + encodeURIComponent('' + lastname) + '&'
    if (aboutmember !== undefined && aboutmember !== null)
      url_ += 'aboutmember=' + encodeURIComponent('' + aboutmember) + '&'
    if (email !== undefined && email !== null)
      url_ += 'email=' + encodeURIComponent('' + email) + '&'
    if (nationality !== undefined && nationality !== null)
      url_ += 'nationality=' + encodeURIComponent('' + nationality) + '&'
    if (residencecountry !== undefined && residencecountry !== null)
      url_ += 'residencecountry=' + encodeURIComponent('' + residencecountry) + '&'
    if (jobposition !== undefined && jobposition !== null)
      url_ += 'jobposition=' + encodeURIComponent('' + jobposition) + '&'
    if (education !== undefined && education !== null)
      url_ += 'education=' + encodeURIComponent('' + education) + '&'
    if (linkedin !== undefined && linkedin !== null)
      url_ += 'linkedin=' + encodeURIComponent('' + linkedin) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUniversityTeamMemberPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUniversityTeamMemberPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUniversityTeamMemberPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  deactivate(body: DeactivateTeamMemberCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/university-team-member/deactivate'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeactivate(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeactivate(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processDeactivate(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProgramsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  questions(id: string): Observable<ListProgramQuestionByProgramIdViewModel[]> {
    let url_ = this.baseUrl + '/api/programs/{id}/questions'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processQuestions(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processQuestions(<any>response_)
            } catch (e) {
              return <Observable<ListProgramQuestionByProgramIdViewModel[]>>(
                (<any>_observableThrow(e))
              )
            }
          } else
            return <Observable<ListProgramQuestionByProgramIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processQuestions(
    response: HttpResponseBase
  ): Observable<ListProgramQuestionByProgramIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListProgramQuestionByProgramIdViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListProgramQuestionByProgramIdViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  userPrograms(): Observable<ListProgramByUserModuleViewModel[]> {
    let url_ = this.baseUrl + '/api/programs/user-programs'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUserPrograms(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUserPrograms(<any>response_)
            } catch (e) {
              return <Observable<ListProgramByUserModuleViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListProgramByUserModuleViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processUserPrograms(
    response: HttpResponseBase
  ): Observable<ListProgramByUserModuleViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListProgramByUserModuleViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListProgramByUserModuleViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  programs(id: string): Observable<GetProgramByIdViewModel> {
    let url_ = this.baseUrl + '/api/programs/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPrograms(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPrograms(<any>response_)
            } catch (e) {
              return <Observable<GetProgramByIdViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetProgramByIdViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processPrograms(response: HttpResponseBase): Observable<GetProgramByIdViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = GetProgramByIdViewModel.fromJS(resultData200)
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetProgramByIdViewModel>(<any>null)
  }

  /**
   * @return Success
   */
  inprogressPrograms(): Observable<ListProgramByCohortContactViewModel[]> {
    let url_ = this.baseUrl + '/api/programs/inprogress-programs'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInprogressPrograms(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInprogressPrograms(<any>response_)
            } catch (e) {
              return <Observable<ListProgramByCohortContactViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListProgramByCohortContactViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processInprogressPrograms(
    response: HttpResponseBase
  ): Observable<ListProgramByCohortContactViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListProgramByCohortContactViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListProgramByCohortContactViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  activeProgram(): Observable<GetActiveProgramViewModel> {
    let url_ = this.baseUrl + '/api/programs/active-program'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processActiveProgram(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processActiveProgram(<any>response_)
            } catch (e) {
              return <Observable<GetActiveProgramViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetActiveProgramViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processActiveProgram(
    response: HttpResponseBase
  ): Observable<GetActiveProgramViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetActiveProgramViewModel>(<any>null)
  }

  /**
   * @return Success
   */
  suggestedPrograms(): Observable<ListAlumniAvailableProgramViewModel[]> {
    let url_ = this.baseUrl + '/api/programs/suggested-programs'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSuggestedPrograms(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSuggestedPrograms(<any>response_)
            } catch (e) {
              return <Observable<ListAlumniAvailableProgramViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListAlumniAvailableProgramViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processSuggestedPrograms(
    response: HttpResponseBase
  ): Observable<ListAlumniAvailableProgramViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListAlumniAvailableProgramViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  graduatedPrograms(): Observable<ListAlumniGraduatedProgramViewModel[]> {
    let url_ = this.baseUrl + '/api/programs/graduated-programs'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGraduatedPrograms(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGraduatedPrograms(<any>response_)
            } catch (e) {
              return <Observable<ListAlumniGraduatedProgramViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListAlumniGraduatedProgramViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processGraduatedPrograms(
    response: HttpResponseBase
  ): Observable<ListAlumniGraduatedProgramViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListAlumniGraduatedProgramViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  allPrograms(): Observable<ListAllProgramsViewModel[]> {
    let url_ = this.baseUrl + '/api/programs/all-programs'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAllPrograms(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAllPrograms(<any>response_)
            } catch (e) {
              return <Observable<ListAllProgramsViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListAllProgramsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAllPrograms(response: HttpResponseBase): Observable<ListAllProgramsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListAllProgramsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  cohortYears(programId): Observable<number[]> {
    let url_ = this.baseUrl + '/api/programs/cohort-years?'
    url_ += 'programId=' + encodeURIComponent('' + programId);
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCohortYears(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCohortYears(<any>response_)
            } catch (e) {
              return <Observable<number[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<number[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processCohortYears(response: HttpResponseBase): Observable<number[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<number[]>(<any>null)
  }

  /**
   * @return Success
   */
  allActivePrograms(): Observable<ListActiveProgramsViewModel[]> {
    let url_ = this.baseUrl + '/api/programs/all-active-programs'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAllActivePrograms(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAllActivePrograms(<any>response_)
            } catch (e) {
              return <Observable<ListActiveProgramsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListActiveProgramsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAllActivePrograms(
    response: HttpResponseBase
  ): Observable<ListActiveProgramsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListActiveProgramsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  programDetails(id: string): Observable<GetProgramDetailsByIdViewModel> {
    let url_ = this.baseUrl + '/api/programs/program-details/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProgramDetails(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProgramDetails(<any>response_)
            } catch (e) {
              return <Observable<GetProgramDetailsByIdViewModel>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<GetProgramDetailsByIdViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProgramDetails(
    response: HttpResponseBase
  ): Observable<GetProgramDetailsByIdViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetProgramDetailsByIdViewModel>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProjectsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  applicantProjects(): Observable<ListApplicantProjectsViewModel[]> {
    let url_ = this.baseUrl + '/api/projects/applicant-projects'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApplicantProjects(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApplicantProjects(<any>response_)
            } catch (e) {
              return <Observable<ListApplicantProjectsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListApplicantProjectsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processApplicantProjects(
    response: HttpResponseBase
  ): Observable<ListApplicantProjectsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListApplicantProjectsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  applicantCompletedProjects(): Observable<ListApplicantCompletedProjectsViewModel[]> {
    let url_ = this.baseUrl + '/api/projects/applicant-completed-projects'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApplicantCompletedProjects(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApplicantCompletedProjects(<any>response_)
            } catch (e) {
              return <Observable<ListApplicantCompletedProjectsViewModel[]>>(
                (<any>_observableThrow(e))
              )
            }
          } else
            return <Observable<ListApplicantCompletedProjectsViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processApplicantCompletedProjects(
    response: HttpResponseBase
  ): Observable<ListApplicantCompletedProjectsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListApplicantCompletedProjectsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListApplicantCompletedProjectsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  underreviewProjects(moduleId: string): Observable<ListInstructorProjectsViewModel[]> {
    let url_ = this.baseUrl + '/api/projects/underreview-projects/{moduleId}'
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace('{moduleId}', encodeURIComponent('' + moduleId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUnderreviewProjects(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUnderreviewProjects(<any>response_)
            } catch (e) {
              return <Observable<ListInstructorProjectsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListInstructorProjectsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processUnderreviewProjects(
    response: HttpResponseBase
  ): Observable<ListInstructorProjectsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListInstructorProjectsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListInstructorProjectsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  instructorTemplateProject(moduleId: string): Observable<GetInstructorProjectViewModel[]> {
    let url_ = this.baseUrl + '/api/projects/instructor-template-project/{moduleId}'
    if (moduleId === undefined || moduleId === null)
      throw new Error("The parameter 'moduleId' must be defined.")
    url_ = url_.replace('{moduleId}', encodeURIComponent('' + moduleId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInstructorTemplateProject(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInstructorTemplateProject(<any>response_)
            } catch (e) {
              return <Observable<GetInstructorProjectViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<GetInstructorProjectViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processInstructorTemplateProject(
    response: HttpResponseBase
  ): Observable<GetInstructorProjectViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(GetInstructorProjectViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetInstructorProjectViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  instructorProjectPost(body: CreateInstructorProjectCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/projects/instructor-project'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInstructorProjectPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInstructorProjectPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processInstructorProjectPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  instructorProjectPut(body: EditInstructorProjectCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/projects/instructor-project'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInstructorProjectPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInstructorProjectPut(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processInstructorProjectPut(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param projectId (optional)
   * @param name (optional)
   * @param name_ar (optional)
   * @param description (optional)
   * @param description_ar (optional)
   * @param topicId (optional)
   * @param status (optional)
   * @param file (optional)
   * @return Success
   */
  applicantProject(
    projectId: string | undefined,
    name: string | null | undefined,
    name_ar: string | null | undefined,
    description: string | null | undefined,
    description_ar: string | null | undefined,
    topicId: string | undefined,
    status: number | undefined,
    file: FileParameter | null | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + '/api/projects/applicant-project?'
    if (projectId === null) throw new Error("The parameter 'projectId' cannot be null.")
    else if (projectId !== undefined)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&'
    if (name !== undefined && name !== null) url_ += 'name=' + encodeURIComponent('' + name) + '&'
    if (name_ar !== undefined && name_ar !== null)
      url_ += 'name_ar=' + encodeURIComponent('' + name_ar) + '&'
    if (description !== undefined && description !== null)
      url_ += 'description=' + encodeURIComponent('' + description) + '&'
    if (description_ar !== undefined && description_ar !== null)
      url_ += 'description_ar=' + encodeURIComponent('' + description_ar) + '&'
    if (topicId === null) throw new Error("The parameter 'topicId' cannot be null.")
    else if (topicId !== undefined) url_ += 'topicId=' + encodeURIComponent('' + topicId) + '&'
    if (status === null) throw new Error("The parameter 'status' cannot be null.")
    else if (status !== undefined) url_ += 'status=' + encodeURIComponent('' + status) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApplicantProject(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApplicantProject(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processApplicantProject(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param projectId (optional)
   * @param file (optional)
   * @return Success
   */
  addAttachment(
    projectId: string | undefined,
    summary_reason: string | null | undefined,
    file: FileParameter | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/projects/add-attachment?'
    if (projectId === null) throw new Error("The parameter 'projectId' cannot be null.")
    else if (projectId !== undefined)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&'
    if (summary_reason !== undefined && summary_reason !== null)
      url_ += 'summary_reason=' + encodeURIComponent('' + summary_reason) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddAttachment(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddAttachment(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processAddAttachment(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  approveProject(body: SetProjectApprovalCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/projects/approve-project'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApproveProject(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApproveProject(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processApproveProject(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @return Success
   */
  groupProjects(): Observable<ListGroupProjectsViewModel[]> {
    let url_ = this.baseUrl + '/api/projects/group-projects'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGroupProjects(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGroupProjects(<any>response_)
            } catch (e) {
              return <Observable<ListGroupProjectsViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListGroupProjectsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processGroupProjects(
    response: HttpResponseBase
  ): Observable<ListGroupProjectsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListGroupProjectsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  projects(id: string): Observable<GetProjectByIdViewModel> {
    let url_ = this.baseUrl + '/api/projects/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProjects(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProjects(<any>response_)
            } catch (e) {
              return <Observable<GetProjectByIdViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetProjectByIdViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProjects(response: HttpResponseBase): Observable<GetProjectByIdViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetProjectByIdViewModel>(<any>null)
  }

  /**
   * @return Success
   */
  cohortProjects(cohortId: string): Observable<ListProjectsByCohortIdViewModel[]> {
    let url_ = this.baseUrl + '/api/projects/cohort-projects/{cohortId}'
    if (cohortId === undefined || cohortId === null)
      throw new Error("The parameter 'cohortId' must be defined.")
    url_ = url_.replace('{cohortId}', encodeURIComponent('' + cohortId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCohortProjects(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCohortProjects(<any>response_)
            } catch (e) {
              return <Observable<ListProjectsByCohortIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListProjectsByCohortIdViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processCohortProjects(
    response: HttpResponseBase
  ): Observable<ListProjectsByCohortIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListProjectsByCohortIdViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ReferencesClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  referencesGet(): Observable<ListUserReferencesViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/references'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReferencesGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReferencesGet(<any>response_)
            } catch (e) {
              return <Observable<ListUserReferencesViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListUserReferencesViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processReferencesGet(
    response: HttpResponseBase
  ): Observable<ListUserReferencesViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListUserReferencesViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserReferencesViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  referencesPost(body: AddReferenceCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/profile/references'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReferencesPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReferencesPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processReferencesPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  referencesPut(id: string, body: EditReferenceCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/references/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReferencesPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReferencesPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processReferencesPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  referencesDelete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/references/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReferencesDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReferencesDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processReferencesDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class RegisterClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @param body (optional)
   * @return Success
   */
  register(body: RegisterNewUserCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/register'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processRegister(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param token (optional)
   * @return Success
   */
  profile(token: string | null | undefined): Observable<any> {
    let url_ = this.baseUrl + '/api/register/uae/profile?'
    if (token !== undefined && token !== null)
      url_ += 'token=' + encodeURIComponent('' + token) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processProfile(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processProfile(<any>response_)
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e))
            }
          } else return <Observable<any>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processProfile(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListModulesByProgramIdViewModel.fromJS(item))
          }
          return _observableOf(resultData200)
        })
      )
    }
  }

  /**
   * @param code (optional)
   * @param redirectUrl (optional)
   * @return Success
   */
  token(code: string | null | undefined, redirectUrl: string | null | undefined): Observable<any> {
    let url_ = this.baseUrl + '/api/register/uae/token?'
    if (code !== undefined && code !== null) url_ += 'code=' + encodeURIComponent('' + code) + '&'
    if (redirectUrl !== undefined && redirectUrl !== null)
      url_ += 'redirectUrl=' + encodeURIComponent('' + redirectUrl) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processToken(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processToken(<any>response_)
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e))
            }
          } else return <Observable<any>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processToken(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListModulesByProgramIdViewModel.fromJS(item))
          }
          return _observableOf(resultData200)
        })
      )
    }
  }

  /**
   * @return Success
   */
  config(): Observable<any> {
    let url_ = this.baseUrl + '/api/register/uae/config'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processConfig(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processConfig(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processConfig(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(resultData200)
        })
      )
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<any>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class ResetPasswordClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetPassword(body: ResetPasswordCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/reset-password'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processResetPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class SectionsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  materialSections(materialId: string): Observable<ListSectionsByMaterialIdViewModel[]> {
    let url_ = this.baseUrl + '/api/sections/material-sections/{materialId}'
    if (materialId === undefined || materialId === null)
      throw new Error("The parameter 'materialId' must be defined.")
    url_ = url_.replace('{materialId}', encodeURIComponent('' + materialId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMaterialSections(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMaterialSections(<any>response_)
            } catch (e) {
              return <Observable<ListSectionsByMaterialIdViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListSectionsByMaterialIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processMaterialSections(
    response: HttpResponseBase
  ): Observable<ListSectionsByMaterialIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListSectionsByMaterialIdViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  sectionsGet(id: string): Observable<GetSectionByIdViewModel> {
    let url_ = this.baseUrl + '/api/sections/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSectionsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSectionsGet(<any>response_)
            } catch (e) {
              return <Observable<GetSectionByIdViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetSectionByIdViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSectionsGet(response: HttpResponseBase): Observable<GetSectionByIdViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetSectionByIdViewModel>(<any>null)
  }

  /**
   * @param sectionId (optional)
   * @param materialId (optional)
   * @param name (optional)
   * @param name_ar (optional)
   * @param duration (optional)
   * @param order (optional)
   * @param startdate (optional)
   * @param publishdate (optional)
   * @param sectionstatus (optional)
   * @return Success
   */
  sectionsPost(
    sectionId: string | undefined,
    materialId: string | undefined,
    name: string | null | undefined,
    name_ar: string | null | undefined,
    duration: number | undefined,
    order: number | undefined,
    startdate: Date | null | undefined,
    publishdate?: Date | null | undefined,
    sectionstatus?: MaterialStatuses | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/sections?'
    if (sectionId === null) throw new Error("The parameter 'sectionId' cannot be null.")
    else if (sectionId !== undefined)
      url_ += 'sectionId=' + encodeURIComponent('' + sectionId) + '&'
    if (materialId === null) throw new Error("The parameter 'materialId' cannot be null.")
    else if (materialId !== undefined)
      url_ += 'materialId=' + encodeURIComponent('' + materialId) + '&'
    if (name !== undefined && name !== null) url_ += 'name=' + encodeURIComponent('' + name) + '&'
    if (name_ar !== undefined && name_ar !== null)
      url_ += 'name_ar=' + encodeURIComponent('' + name_ar) + '&'
    if (duration === null) throw new Error("The parameter 'duration' cannot be null.")
    else if (duration !== undefined) url_ += 'duration=' + encodeURIComponent('' + duration) + '&'
    if (order === null) throw new Error("The parameter 'order' cannot be null.")
    else if (order !== undefined) url_ += 'order=' + encodeURIComponent('' + order) + '&'
    if (startdate !== undefined && startdate !== null)
      url_ += 'startdate=' + encodeURIComponent(startdate ? '' + startdate.toJSON() : '') + '&'
    if (publishdate !== undefined && publishdate !== null)
      url_ +=
        'publishdate=' + encodeURIComponent(publishdate ? '' + publishdate.toJSON() : '') + '&'
    if (sectionstatus === null) throw new Error("The parameter 'sectionstatus' cannot be null.")
    else if (sectionstatus !== undefined)
      url_ += 'sectionstatus=' + encodeURIComponent('' + sectionstatus) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSectionsPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSectionsPost(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSectionsPost(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @param sectionId (optional)
   * @param status (optional)
   * @return Success
   */
  sectionsPut(sectionId: string | undefined, status: number | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/sections?'
    if (sectionId === null) throw new Error("The parameter 'sectionId' cannot be null.")
    else if (sectionId !== undefined)
      url_ += 'sectionId=' + encodeURIComponent('' + sectionId) + '&'
    if (status === null) throw new Error("The parameter 'status' cannot be null.")
    else if (status !== undefined) url_ += 'status=' + encodeURIComponent('' + status) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSectionsPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSectionsPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSectionsPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  cohortSections(materialId: string): Observable<ListSectionsByCohortMaterialIdViewModel[]> {
    let url_ = this.baseUrl + '/api/sections/cohort-sections/{materialId}'
    if (materialId === undefined || materialId === null)
      throw new Error("The parameter 'materialId' must be defined.")
    url_ = url_.replace('{materialId}', encodeURIComponent('' + materialId))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCohortSections(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCohortSections(<any>response_)
            } catch (e) {
              return <Observable<ListSectionsByCohortMaterialIdViewModel[]>>(
                (<any>_observableThrow(e))
              )
            }
          } else
            return <Observable<ListSectionsByCohortMaterialIdViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processCohortSections(
    response: HttpResponseBase
  ): Observable<ListSectionsByCohortMaterialIdViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(item)
          } else {
            result200 = <any>null
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListSectionsByCohortMaterialIdViewModel[]>(<any>null)
  }
  s
}

@Injectable({
  providedIn: 'root',
})
export class PostsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  postsGet(): Observable<ListPostsViewModel[]> {
    let url_ = this.baseUrl + '/api/posts'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPostsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPostsGet(<any>response_)
            } catch (e) {
              return <Observable<ListPostsViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListPostsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processPostsGet(response: HttpResponseBase): Observable<ListPostsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListPostsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListPostsViewModel[]>(<any>null)
  }

  /**
   * @return Success
   */
  postsGetById(id: string): Observable<ListPostsViewModel> {
    let url_ = this.baseUrl + '/api/posts/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPostsGetById(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPostsGetById(<any>response_)
            } catch (e) {
              return <Observable<ListPostsViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListPostsViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processPostsGetById(response: HttpResponseBase): Observable<ListPostsViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<ListPostsViewModel>(<any>null)
        })
      )
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result422: any = null
          let resultData422 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result422 = ApiProblemDetails.fromJS(resultData422)
          return throwException('Client Error', status, _responseText, _headers, result422)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListPostsViewModel>(responseBlob)
  }

  /**
   * @return Success
   */
  search(text: string | null): Observable<SearchArticlesViewModel[]> {
    let url_ = this.baseUrl + '/api/posts/search/{text}'
    if (text === undefined || text === null)
      throw new Error("The parameter 'text' must be defined.")
    url_ = url_.replace('{text}', encodeURIComponent('' + text))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSearch(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSearch(<any>response_)
            } catch (e) {
              return <Observable<SearchArticlesViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<SearchArticlesViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSearch(response: HttpResponseBase): Observable<SearchArticlesViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(SearchArticlesViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<SearchArticlesViewModel[]>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class RightPanelClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  pinnedGet(): Observable<PinnedPostsViewModel> {
    let url_ = this.baseUrl + '/api/panel/pinned'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPinnedGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPinnedGet(<any>response_)
            } catch (e) {
              return <Observable<PinnedPostsViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<PinnedPostsViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processPinnedGet(response: HttpResponseBase): Observable<PinnedPostsViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)

          return _observableOf(resultData200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<PinnedPostsViewModel>(<any>null)
  }

  currentProgramGet(): Observable<GetCurrentActiveProgramViewModel> {
    let url_ = this.baseUrl + '/api/panel/current-program'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCurrentProgramGets(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCurrentProgramGets(<any>response_)
            } catch (e) {
              return <Observable<GetCurrentActiveProgramViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetCurrentActiveProgramViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processCurrentProgramGets(response: HttpResponseBase): Observable<GetCurrentActiveProgramViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)

          return _observableOf(resultData200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetCurrentActiveProgramViewModel>(<any>null)
  }
  currentModuleGet(): Observable<GetCurrentActiveModuleViewModel> {
    let url_ = this.baseUrl + '/api/panel/current-module'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCurrentModuleGets(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCurrentModuleGets(<any>response_)
            } catch (e) {
              return <Observable<GetCurrentActiveModuleViewModel>>(<any>_observableThrow(e))
            }
          } else return <Observable<GetCurrentActiveModuleViewModel>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processCurrentModuleGets(response: HttpResponseBase): Observable<GetCurrentActiveModuleViewModel> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          return _observableOf(resultData200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<GetCurrentActiveModuleViewModel>(<any>null)
  }

  listsGet(): Observable<Panel3ViewModel[]> {
    let url_ = this.baseUrl + '/api/panel/lists'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processListsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processListsGet(<any>response_)
            } catch (e) {
              return <Observable<Panel3ViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<Panel3ViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processListsGet(response: HttpResponseBase): Observable<Panel3ViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(Panel3ViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<Panel3ViewModel[]>(<any>null)
  }



}
export interface IPinnedPostsViewModel {
  videoUrl?: string | undefined;
}
export class GetCurrentActiveProgramViewModel implements IGetCurrentActiveProgramViewModel {
  id: string;
  name: string;
  description: string;
  pictureUrl: string;
  constructor(data?: IGetCurrentActiveProgramViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id	'];

      this.name = _data['name'];

      this.description = _data['description'];

      this.pictureUrl = _data['pictureUrl']
    }
  }

  static fromJS(data: any): GetCurrentActiveProgramViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetCurrentActiveProgramViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    data['pictureUrl'] = this.pictureUrl;
    return data
  }
}
export interface IGetCurrentActiveProgramViewModel {
  id: string | undefined;
  name: string | undefined;
  description: string | undefined;
  pictureUrl: string | undefined;
}

export interface IGetCurrentActiveModuleViewModel {
  id: string | undefined;
  name: string | undefined;
  description: string | undefined;
  pictureUrl: string | undefined;
  programId: string | undefined
}
export class GetCurrentActiveModuleViewModel implements IGetCurrentActiveProgramViewModel {
  id: string;
  name: string;
  description: string;
  pictureUrl: string;
  programId: string;
  constructor(data?: IGetCurrentActiveProgramViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id	'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.pictureUrl = _data['pictureUrl'];
      this.programId = _data['programId'];
    }
  }

  static fromJS(data: any): GetCurrentActiveProgramViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetCurrentActiveProgramViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    data['pictureUrl'] = this.pictureUrl;
    data['programId'] = this.programId;
    return data
  }
}

export class PinnedPostsViewModel implements IPinnedPostsViewModel {
  videoUrl?: string | undefined;

  constructor(data?: IPinnedPostsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.videoUrl = _data['videoUrl']
    }
  }

  static fromJS(data: any): PinnedPostsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new PinnedPostsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['videoUrl'] = this.videoUrl
    return data
  }
}

export class Panel3ViewModel implements IPanel3ViewModel {
  title: string | undefined;
  number: number | undefined;
  title_AR: string | undefined;
  constructor(data?: IPanel3ViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title']
      this.title_AR = _data['title_AR']
      this.number = _data['number']
    }
  }

  static fromJS(data: any): Panel3ViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new Panel3ViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['title'] = this.title
    data['title_AR'] = this.title_AR
    data['number'] = this.number
    return data
  }
}
export interface IPanel3ViewModel {
  title: string | undefined;
  title_AR: string | undefined;
  number: number | undefined;
}

@Injectable({
  providedIn: 'root',
})
export class SkillsAndInterestsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  skillsAndInterestsGet(): Observable<ListUserSkillsAndInterestsViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/skills-and-interests'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSkillsAndInterestsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSkillsAndInterestsGet(<any>response_)
            } catch (e) {
              return <Observable<ListUserSkillsAndInterestsViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListUserSkillsAndInterestsViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processSkillsAndInterestsGet(
    response: HttpResponseBase
  ): Observable<ListUserSkillsAndInterestsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListUserSkillsAndInterestsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserSkillsAndInterestsViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  skillsAndInterestsPost(body: AddInterestCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/profile/skills-and-interests'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSkillsAndInterestsPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSkillsAndInterestsPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSkillsAndInterestsPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  skillsAndInterestsPut(id: string, body: EditInterestCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/skills-and-interests/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSkillsAndInterestsPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSkillsAndInterestsPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSkillsAndInterestsPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  skillsAndInterestsDelete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/skills-and-interests/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSkillsAndInterestsDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSkillsAndInterestsDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processSkillsAndInterestsDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

export class UpdateOverviewCommand implements IUpdateOverviewCommand {
  id?: string
  overview?: string | undefined

  constructor(data?: IUpdateOverviewCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.overview = _data['overview']
    }
  }

  static fromJS(data: any): UpdateOverviewCommand {
    data = typeof data === 'object' ? data : {}
    let result = new UpdateOverviewCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['overview'] = this.overview
    return data
  }
}

export interface IUpdateOverviewCommand {
  id?: string
  overview?: string | undefined
}

export class GetInstructorProfileViewModel implements IGetInstructorProfileViewModel {
  id?: string
  name?: string | undefined
  email?: string | undefined
  nationality?: string | undefined
  residenceCountry?: string | undefined
  aboutInstructor?: string | undefined
  linkedInUrl?: string | undefined
  profilePictureUrl?: string | undefined
  jobTitle?: string | undefined
  organization?: string | undefined
  education?: string | undefined

  constructor(data?: IGetInstructorProfileViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.email = _data['email']
      this.nationality = _data['nationality']
      this.residenceCountry = _data['residenceCountry']
      this.aboutInstructor = _data['aboutInstructor']
      this.linkedInUrl = _data['linkedInUrl']
      this.profilePictureUrl = _data['profilePictureUrl']
      this.jobTitle = _data['jobTitle']
      this.organization = _data['organization']
      this.education = _data['education']
    }
  }

  static fromJS(data: any): GetInstructorProfileViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetInstructorProfileViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['email'] = this.email
    data['nationality'] = this.nationality
    data['residenceCountry'] = this.residenceCountry
    data['aboutInstructor'] = this.aboutInstructor
    data['linkedInUrl'] = this.linkedInUrl
    data['profilePictureUrl'] = this.profilePictureUrl
    data['jobTitle'] = this.jobTitle
    data['organization'] = this.organization
    data['education'] = this.education
    return data
  }
}

export interface IGetInstructorProfileViewModel {
  id?: string
  name?: string | undefined
  email?: string | undefined
  nationality?: string | undefined
  residenceCountry?: string | undefined
  aboutInstructor?: string | undefined
  linkedInUrl?: string | undefined
  profilePictureUrl?: string | undefined
  jobTitle?: string | undefined
  organization?: string | undefined
  education?: string | undefined
}

@Injectable({
  providedIn: 'root',
})
export class TrainingCoursesClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  trainingCoursesGet(): Observable<ListUserTrainingCoursesViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/training-courses'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTrainingCoursesGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTrainingCoursesGet(<any>response_)
            } catch (e) {
              return <Observable<ListUserTrainingCoursesViewModel[]>>(<any>_observableThrow(e))
            }
          } else
            return <Observable<ListUserTrainingCoursesViewModel[]>>(
              (<any>_observableThrow(response_))
            )
        })
      )
  }

  protected processTrainingCoursesGet(
    response: HttpResponseBase
  ): Observable<ListUserTrainingCoursesViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200)
              result200!.push(ListUserTrainingCoursesViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserTrainingCoursesViewModel[]>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  trainingCoursesPost(body: AddTrainingCourseCommand | undefined): Observable<string> {
    let url_ = this.baseUrl + '/api/profile/training-courses'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
        'Accept': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTrainingCoursesPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTrainingCoursesPost(<any>response_)
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e))
            }
          } else return <Observable<string>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processTrainingCoursesPost(response: HttpResponseBase): Observable<string> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          result200 = resultData200 !== undefined ? resultData200 : <any>null
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<string>(<any>null)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  trainingCoursesPut(id: string, body: EditTrainingCourseCommand | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/training-courses/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTrainingCoursesPut(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTrainingCoursesPut(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processTrainingCoursesPut(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  trainingCoursesDelete(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/training-courses/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTrainingCoursesDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTrainingCoursesDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processTrainingCoursesDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }
}

@Injectable({
  providedIn: 'root',
})
export class UserDocumentsClient {
  private http: HttpClient
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ''
  }

  /**
   * @return Success
   */
  documentsGet(): Observable<ListUserDocumentsViewModel[]> {
    let url_ = this.baseUrl + '/api/profile/documents'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json;odata.metadata=minimal;odata.streaming=true',
      }),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDocumentsGet(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDocumentsGet(<any>response_)
            } catch (e) {
              return <Observable<ListUserDocumentsViewModel[]>>(<any>_observableThrow(e))
            }
          } else return <Observable<ListUserDocumentsViewModel[]>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processDocumentsGet(
    response: HttpResponseBase
  ): Observable<ListUserDocumentsViewModel[]> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
          if (Array.isArray(resultData200)) {
            result200 = [] as any
            for (let item of resultData200) result200!.push(ListUserDocumentsViewModel.fromJS(item))
          }
          return _observableOf(result200)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<ListUserDocumentsViewModel[]>(<any>null)
  }

  /**
   * @param file (optional)
   * @return Success
   */
  documentsPost(id: string | null, file: FileParameter | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/documents/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    const content_ = new FormData()
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file')

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDocumentsPost(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDocumentsPost(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processDocumentsPost(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  documentsDelete(id: string | null): Observable<void> {
    let url_ = this.baseUrl + '/api/profile/documents/{id}'
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace('{id}', encodeURIComponent('' + id))
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDocumentsDelete(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDocumentsDelete(<any>response_)
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e))
            }
          } else return <Observable<void>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processDocumentsDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null)
        })
      )
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<void>(<any>null)
  }

  /**
   * @return Success
   */
  roleUserManual(): Observable<any> {
    let url_ = this.baseUrl + '/api/profile/documents/role-user-manual'
    url_ = url_.replace(/[?&]$/, '')

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    }

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRoleUserManual(response_)
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRoleUserManual(<any>response_)
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e))
            }
          } else return <Observable<any>>(<any>_observableThrow(response_))
        })
      )
  }

  protected processRoleUserManual(response: HttpResponseBase): Observable<any> {
    const status = response.status
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined

    let _headers: any = {}
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key)
      }
    }
    if (status === 200) {
      var file = new Blob([responseBlob], { type: 'application/pdf' })
      var fileURL = URL.createObjectURL(file)
      return _observableOf(fileURL)
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers)
        })
      )
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          )
        })
      )
    }
    return _observableOf<any>(<any>null)
  }
}

export class ChangePasswordCommand implements IChangePasswordCommand {
  userId?: string
  currentPassword?: string | undefined
  newPassword?: string | undefined

  constructor(data?: IChangePasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId']
      this.currentPassword = _data['currentPassword']
      this.newPassword = _data['newPassword']
    }
  }

  static fromJS(data: any): ChangePasswordCommand {
    data = typeof data === 'object' ? data : {}
    let result = new ChangePasswordCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['userId'] = this.userId
    data['currentPassword'] = this.currentPassword
    data['newPassword'] = this.newPassword
    return data
  }
}

export interface IChangePasswordCommand {
  userId?: string
  currentPassword?: string | undefined
  newPassword?: string | undefined
}

export class ChangeEmailCommand implements IChangeEmailCommand {
  userId?: string
  newEmail?: string | undefined

  constructor(data?: IChangeEmailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId']
      this.newEmail = _data['newEmail']
    }
  }

  static fromJS(data: any): ChangeEmailCommand {
    data = typeof data === 'object' ? data : {}
    let result = new ChangeEmailCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['userId'] = this.userId
    data['newEmail'] = this.newEmail
    return data
  }
}

export interface IChangeEmailCommand {
  userId?: string
  newEmail?: string | undefined
}

export class DeleteAccountCommand implements IDeleteAccountCommand {
  email?: string | undefined

  constructor(data?: IChangeEmailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email']
    }
  }

  static fromJS(data: any): DeleteAccountCommand {
    data = typeof data === 'object' ? data : {}
    let result = new DeleteAccountCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['email'] = this.email
    return data
  }
}

export interface IDeleteAccountCommand {
  email?: string
}

export class SearchAlumniViewModel implements ISearchAlumniViewModel {
  id?: string
  fullName?: string | undefined
  profilePictureUrl?: string | undefined

  constructor(data?: ISearchAlumniViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.fullName = _data['FullName']
      this.profilePictureUrl = _data['ProfilePictureUrl']
    }
  }

  static fromJS(data: any): SearchAlumniViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new SearchAlumniViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['FullName'] = this.fullName
    data['ProfilePictureUrl'] = this.profilePictureUrl
    return data
  }
}

export interface ISearchAlumniViewModel {
  id?: string
  fullName?: string | undefined
  profilePictureUrl?: string | undefined
}

export class ListUserAchievementsViewModel implements IListUserAchievementsViewModel {
  id?: string
  completed?: boolean
  description?: string | undefined
  description_AR?: string | undefined
  summaryOfAchievement?: string | undefined
  summaryOfAchievement_AR?: string | undefined
  populationImpact?: number
  achievementImpact?: number
  financialImpact?: number
  organization?: string | undefined
  organization_AR?: string | undefined
  yearOfAchievement?: string | undefined

  constructor(data?: IListUserAchievementsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.summaryOfAchievement = _data['summaryOfAchievement']
      this.summaryOfAchievement_AR = _data['summaryOfAchievement_AR']
      this.populationImpact = _data['populationImpact']
      this.achievementImpact = _data['achievementImpact']
      this.financialImpact = _data['financialImpact']
      this.organization = _data['organization']
      this.organization_AR = _data['organization_AR']
      this.yearOfAchievement = _data['yearOfAchievement']
      this.completed = _data['completed']
    }
  }

  static fromJS(data: any): ListUserAchievementsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserAchievementsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['summaryOfAchievement'] = this.summaryOfAchievement
    data['summaryOfAchievement_AR'] = this.summaryOfAchievement_AR
    data['populationImpact'] = this.populationImpact
    data['achievementImpact'] = this.achievementImpact
    data['financialImpact'] = this.financialImpact
    data['organization'] = this.organization
    data['organization_AR'] = this.organization_AR
    data['yearOfAchievement'] = this.yearOfAchievement
    data['completed'] = this.completed
    return data
  }
}

export interface IListUserAchievementsViewModel {
  id?: string
  description?: string | undefined
  description_AR?: string | undefined
  summaryOfAchievement?: string | undefined
  summaryOfAchievement_AR?: string | undefined
  populationImpact?: number
  achievementImpact?: number
  financialImpact?: number
  organization?: string | undefined
  organization_AR?: string | undefined
  yearOfAchievement?: string | undefined
}

export class ListCommentsByPostIdViewModel implements IListCommentsByPostIdViewModel {
  id?: string
  contactId?: string
  contactName?: string | undefined
  postId?: string | undefined
  action?: number
  actionDate?: Date | undefined
  comment?: string | undefined

  constructor(data?: IListCommentsByPostIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.contactId = _data['contactId']
      this.contactName = _data['contactName']
      this.postId = _data['postId']
      this.action = _data['action']
      this.actionDate = _data['actionDate']
        ? new Date(_data['actionDate'].toString())
        : <any>undefined
      this.comment = _data['comment']
    }
  }

  static fromJS(data: any): ListCommentsByPostIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListCommentsByPostIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['contactId'] = this.contactId
    data['contactName'] = this.contactName
    data['postId'] = this.postId
    data['action'] = this.action
    data['actionDate'] = this.actionDate ? this.actionDate.toISOString() : <any>undefined
    data['comment'] = this.comment
    return data
  }
}

export interface IListCommentsByPostIdViewModel {
  id?: string
  contactId?: string
  contactName?: string | undefined
  postId?: string | undefined
  action?: number
  actionDate?: Date | undefined
  comment?: string | undefined
}

export class AddAchievementCommand implements IAddAchievementCommand {
  description?: string | undefined
  description_AR?: string | undefined
  summaryOfAchievement?: string | undefined
  summaryOfAchievement_AR?: string | undefined
  populationImpact?: number
  achievementImpact?: number
  financialImpact?: number
  organization?: string | undefined
  organization_AR?: string | undefined
  yearOfAchievement?: string | undefined
  contactId?: string

  constructor(data?: IAddAchievementCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.summaryOfAchievement = _data['summaryOfAchievement']
      this.summaryOfAchievement_AR = _data['summaryOfAchievement_AR']
      this.populationImpact = _data['populationImpact']
      this.achievementImpact = _data['achievementImpact']
      this.financialImpact = _data['financialImpact']
      this.organization = _data['organization']
      this.organization_AR = _data['organization_AR']
      this.yearOfAchievement = _data['yearOfAchievement']
      this.contactId = _data['contactId']
    }
  }

  static fromJS(data: any): AddAchievementCommand {
    data = typeof data === 'object' ? data : {}
    let result = new AddAchievementCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['summaryOfAchievement'] = this.summaryOfAchievement
    data['summaryOfAchievement_AR'] = this.summaryOfAchievement_AR
    data['populationImpact'] = this.populationImpact
    data['achievementImpact'] = this.achievementImpact
    data['financialImpact'] = this.financialImpact
    data['organization'] = this.organization
    data['organization_AR'] = this.organization_AR
    data['yearOfAchievement'] = this.yearOfAchievement
    data['contactId'] = this.contactId
    return data
  }
}

export interface IAddAchievementCommand {
  description?: string | undefined
  description_AR?: string | undefined
  summaryOfAchievement?: string | undefined
  summaryOfAchievement_AR?: string | undefined
  populationImpact?: number
  achievementImpact?: number
  financialImpact?: number
  organization?: string | undefined
  organization_AR?: string | undefined
  yearOfAchievement?: string | undefined
  contactId?: string
}

export class EditAchievementCommand implements IEditAchievementCommand {
  id?: string
  description?: string | undefined
  description_AR?: string | undefined
  summaryOfAchievement?: string | undefined
  summaryOfAchievement_AR?: string | undefined
  populationImpact?: number
  achievementImpact?: number
  financialImpact?: number
  organization?: string | undefined
  organization_AR?: string | undefined
  yearOfAchievement?: string | undefined

  constructor(data?: IEditAchievementCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.summaryOfAchievement = _data['summaryOfAchievement']
      this.summaryOfAchievement_AR = _data['summaryOfAchievement_AR']
      this.populationImpact = _data['populationImpact']
      this.achievementImpact = _data['achievementImpact']
      this.financialImpact = _data['financialImpact']
      this.organization = _data['organization']
      this.organization_AR = _data['organization_AR']
      this.yearOfAchievement = _data['yearOfAchievement']
    }
  }

  static fromJS(data: any): EditAchievementCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditAchievementCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['summaryOfAchievement'] = this.summaryOfAchievement
    data['summaryOfAchievement_AR'] = this.summaryOfAchievement_AR
    data['populationImpact'] = this.populationImpact
    data['achievementImpact'] = this.achievementImpact
    data['financialImpact'] = this.financialImpact
    data['organization'] = this.organization
    data['organization_AR'] = this.organization_AR
    data['yearOfAchievement'] = this.yearOfAchievement
    return data
  }
}

export class ListUserProjectIdeasViewModel implements IListUserProjectIdeasViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  date?: Date | undefined
  projectIdeaStatus?: number
  alumni?: string
  alumniName?: string | undefined
  budget?: number
  documentUrl?: string | undefined

  constructor(data?: IListUserProjectIdeasViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.description = _data['Description']
      this.date = _data['Date'] ? new Date(_data['Date'].toString()) : <any>undefined
      this.projectIdeaStatus = _data['ProjectIdeaStatus']
      this.alumni = _data['Alumni']
      this.alumniName = _data['AlumniName']
      this.budget = _data['Budget']
      this.documentUrl = _data['DocumentUrl']
    }
  }

  static fromJS(data: any): ListUserProjectIdeasViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserProjectIdeasViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Description'] = this.description
    data['Date'] = this.date ? this.date.toISOString() : <any>undefined
    data['ProjectIdeaStatus'] = this.projectIdeaStatus
    data['Alumni'] = this.alumni
    data['AlumniName'] = this.alumniName
    data['Budget'] = this.budget
    data['DocumentUrl'] = this.documentUrl
    return data
  }
}

export interface IListUserProjectIdeasViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  date?: Date | undefined
  projectIdeaStatus?: number
  alumni?: string
  alumniName?: string | undefined
  budget?: number
  documentUrl?: string | undefined
}

export interface IEditAchievementCommand {
  id?: string
  description?: string | undefined
  description_AR?: string | undefined
  summaryOfAchievement?: string | undefined
  summaryOfAchievement_AR?: string | undefined
  populationImpact?: number
  achievementImpact?: number
  financialImpact?: number
  organization?: string | undefined
  organization_AR?: string | undefined
  yearOfAchievement?: string | undefined
}

export class ListArticlesViewModel implements IListArticlesViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  date?: Date
  pictureUrl?: string | undefined
  profilePictureUrl?: string | undefined
  writtenBy?: string
  writtenByName?: string | undefined
  liked?: boolean
  likes?: number | undefined

  constructor(data?: IListArticlesViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.description = _data['description']
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined
      this.pictureUrl = _data['pictureUrl']
      this.profilePictureUrl = _data['profilePictureUrl']
      this.writtenBy = _data['writtenBy']
      this.writtenByName = _data['writtenByName']
      this.liked = _data['liked']
      this.likes = _data['likes']
    }
  }

  static fromJS(data: any): ListArticlesViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListArticlesViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['description'] = this.description
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['pictureUrl'] = this.pictureUrl
    data['profilePictureUrl'] = this.profilePictureUrl
    data['writtenBy'] = this.writtenBy
    data['writtenByName'] = this.writtenByName
    data['liked'] = this.liked
    data['likes'] = this.likes
    return data
  }
}

export interface IListArticlesViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  date?: Date
  pictureUrl?: string | undefined
  profilePictureUrl?: string | undefined
  writtenBy?: string
  writtenByName?: string | undefined
  liked?: boolean
  likes?: number | undefined
}

export class ListUserArticlesViewModel implements IListUserArticlesViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  date?: Date
  articleStatus?: number
  pictureUrl?: string | undefined
  writtenBy?: string
  writtenByName?: string | undefined
  liked?: boolean
  likes?: number | undefined

  constructor(data?: IListUserArticlesViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.description = _data['description']
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined
      this.articleStatus = _data['articleStatus']
      this.pictureUrl = _data['pictureUrl']
      this.writtenBy = _data['writtenBy']
      this.writtenByName = _data['writtenByName']
      this.liked = _data['liked']
      this.likes = _data['likes']
    }
  }

  static fromJS(data: any): ListUserArticlesViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserArticlesViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['description'] = this.description
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['articleStatus'] = this.articleStatus
    data['pictureUrl'] = this.pictureUrl
    data['writtenBy'] = this.writtenBy
    data['writtenByName'] = this.writtenByName
    data['liked'] = this.liked
    data['likes'] = this.likes
    return data
  }
}

export interface IListUserArticlesViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  date?: Date
  articleStatus?: number
  pictureUrl?: string | undefined
  writtenBy?: string
  writtenByName?: string | undefined
  liked?: boolean
  likes?: number | undefined
}

export class SearchArticlesViewModel implements ISearchArticlesViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  theArticle?: string | undefined
  articleStatus?: number
  date?: Date
  writtenBy?: string
  writtenByName?: string | undefined
  pictureUrl?: string | undefined
  liked?: boolean
  likes?: number | undefined

  constructor(data?: ISearchArticlesViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.description = _data['description']
      this.theArticle = _data['theArticle']
      this.articleStatus = _data['articleStatus']
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined
      this.writtenBy = _data['writtenBy']
      this.writtenByName = _data['writtenByName']
      this.pictureUrl = _data['pictureUrl']
      this.liked = _data['liked']
      this.likes = _data['likes']
    }
  }

  static fromJS(data: any): SearchArticlesViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new SearchArticlesViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['description'] = this.description
    data['theArticle'] = this.theArticle
    data['articleStatus'] = this.articleStatus
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['writtenBy'] = this.writtenBy
    data['writtenByName'] = this.writtenByName
    data['pictureUrl'] = this.pictureUrl
    data['liked'] = this.liked
    data['likes'] = this.likes
    return data
  }
}

export class SearchUserArticlesViewModel implements ISearchUserArticlesViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  theArticle?: string | undefined
  articleStatus?: number
  date?: Date
  writtenBy?: string
  writtenByName?: string | undefined
  pictureUrl?: string | undefined
  profilePictureUrl?: string | undefined
  liked?: boolean
  likes?: number | undefined

  constructor(data?: ISearchUserArticlesViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.description = _data['description']
      this.theArticle = _data['theArticle']
      this.articleStatus = _data['articleStatus']
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined
      this.writtenBy = _data['writtenBy']
      this.writtenByName = _data['writtenByName']
      this.pictureUrl = _data['pictureUrl']
      this.profilePictureUrl = _data['profilePictureUrl']
      this.liked = _data['liked']
      this.likes = _data['likes']
    }
  }

  static fromJS(data: any): SearchUserArticlesViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new SearchUserArticlesViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['description'] = this.description
    data['theArticle'] = this.theArticle
    data['articleStatus'] = this.articleStatus
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['writtenBy'] = this.writtenBy
    data['writtenByName'] = this.writtenByName
    data['pictureUrl'] = this.pictureUrl
    data['profilePictureUrl'] = this.profilePictureUrl
    data['liked'] = this.liked
    data['likes'] = this.likes
    return data
  }
}

export interface ISearchUserArticlesViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  theArticle?: string | undefined
  articleStatus?: number
  date?: Date
  writtenBy?: string
  writtenByName?: string | undefined
  pictureUrl?: string | undefined
  profilePictureUrl?: string | undefined
  liked?: boolean
  likes?: number | undefined
}

export interface ISearchArticlesViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  theArticle?: string | undefined
  articleStatus?: number
  date?: Date
  writtenBy?: string
  writtenByName?: string | undefined
  pictureUrl?: string | undefined
  liked?: boolean
  likes?: number | undefined
}

export interface IApiProblemDetails {
  errors?: any[] | undefined
  type?: string | undefined
  title?: string | undefined
  status?: number | undefined
  detail?: string | undefined
  instance?: string | undefined
}

export class GetUserCalendarViewModel implements IGetUserCalendarViewModel {
  id?: string
  name?: string | undefined
  startDate?: Date
  endDate?: Date
  duration?: number
  type?: number
  contactID?: string
  eventID?: string
  meetingId?: string

  constructor(data?: IGetUserCalendarViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.startDate = _data['startDate'] ? _data['startDate'] : <any>undefined
      this.endDate = _data['endDate'] ? _data['endDate'] : <any>undefined
      this.duration = _data['duration']
      this.type = _data['type']
      this.contactID = _data['contactID']
      this.eventID = _data['eventID']
      this.meetingId = _data['meetingId']
    }
  }

  static fromJS(data: any): GetUserCalendarViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetUserCalendarViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['startDate'] = this.startDate ? this.startDate : <any>undefined
    data['endDate'] = this.endDate ? this.endDate : <any>undefined
    data['duration'] = this.duration
    data['type'] = this.type
    data['contactID'] = this.contactID
    data['eventID'] = this.eventID
    data['meetingId'] = this.meetingId
    return data
  }
}

export interface IGetUserCalendarViewModel {
  id?: string
  name?: string | undefined
  startDate?: Date
  endDate?: Date
  duration?: number
  type?: number
  contactID?: string
  eventID?: string
  meetingId?: string
}

export class ListContentsBySectionIdViewModel implements IListContentsBySectionIdViewModel {
  id?: string
  name?: string | undefined
  duration?: number
  text?: string | undefined
  type?: number
  url?: string | undefined
  documentUrl?: string | undefined
  order?: number
  startDate?: Date
  sectionId?: string

  constructor(data?: IListContentsBySectionIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.duration = _data['duration']
      this.text = _data['text']
      this.type = _data['type']
      this.url = _data['url']
      this.documentUrl = _data['documentUrl']
      this.order = _data['order']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.sectionId = _data['sectionId']
    }
  }

  static fromJS(data: any): ListContentsBySectionIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListContentsBySectionIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['duration'] = this.duration
    data['text'] = this.text
    data['type'] = this.type
    data['url'] = this.url
    data['documentUrl'] = this.documentUrl
    data['order'] = this.order
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['sectionId'] = this.sectionId
    return data
  }
}

export interface IListContentsBySectionIdViewModel {
  id?: string
  name?: string | undefined
  duration?: number
  text?: string | undefined
  type?: number
  url?: string | undefined
  documentUrl?: string | undefined
  order?: number
  startDate?: Date
  sectionId?: string
}

export enum MessageTypes {
  _0 = 0,
  _1 = 1,
}

export class CreateRoomCommand implements ICreateRoomCommand {
  name?: string | undefined
  moduleId?: string
  instructorId?: string
  participants?: string[] | undefined

  constructor(data?: ICreateRoomCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['Name']
      this.moduleId = _data['ModuleId']
      this.instructorId = _data['InstructorId']
      if (Array.isArray(_data['Participants'])) {
        this.participants = [] as any
        for (let item of _data['Participants']) this.participants!.push(item)
      }
    }
  }

  static fromJS(data: any): CreateRoomCommand {
    data = typeof data === 'object' ? data : {}
    let result = new CreateRoomCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Name'] = this.name
    data['ModuleId'] = this.moduleId
    data['InstructorId'] = this.instructorId
    if (Array.isArray(this.participants)) {
      data['Participants'] = []
      for (let item of this.participants) data['Participants'].push(item)
    }
    return data
  }
}

export interface ICreateRoomCommand {
  name?: string | undefined
  moduleId?: string
  instructorId?: string
  participants?: string[] | undefined
}

export interface IEliteClubViewModel {
  id: string
  isActiveMember: boolean
  name: string
}

export class EliteClubViewModel implements IEliteClubViewModel {
  id: string
  isActiveMember: boolean
  name: string

  constructor(data?: IEliteClubViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.isActiveMember = _data['IsActiveMember']
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['IsActiveMember'] = this.isActiveMember
    return data
  }
}

export interface IEliteClubOverviewViewModel {
  id: string
  overview: string
  name: string
}

export class EliteClubOverviewViewModel implements IEliteClubOverviewViewModel {
  id: string
  overview: string
  name: string

  constructor(data?: IEliteClubOverviewViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.overview = _data['Overview']
    }
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Overview'] = this.overview
    return data
  }
}

export interface IListEliteClubMembersByIdViewModel {
  id?: string
  name?: string | undefined
  profilePictureUrl?: string | undefined
}

export class ListEliteClubMembersByIdViewModel implements IListEliteClubMembersByIdViewModel {
  id?: string
  name?: string | undefined
  profilePictureUrl?: string | undefined

  constructor(data?: IListEliteClubMembersByIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.profilePictureUrl = _data['profilePictureUrl']
    }
  }

  static fromJS(data: any): ListEliteClubMembersByIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListEliteClubMembersByIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['profilePictureUrl'] = this.profilePictureUrl
    return data
  }
}

export interface IElteMembershipAttendance {
  id: string
  name: string
  fromDate: string
  toDate: string
  description: string
  attendanceStatus: number
}

export class ElteMembershipAttendance implements IElteMembershipAttendance {
  id: string
  name: string
  fromDate: string
  toDate: string
  description: string
  attendanceStatus: number

  constructor(data?: IElteMembershipAttendance) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.fromDate = _data['fromDate']
      this.toDate = _data['toDate']
      this.description = _data['description']
      this.attendanceStatus = _data['attendanceStatus']
    }
  }

  static fromJS(data: any): ElteMembershipAttendance {
    data = typeof data === 'object' ? data : {}
    let result = new ElteMembershipAttendance()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['FromDate'] = this.fromDate
    data['ToDate'] = this.toDate
    data['Description'] = this.description
    data['AttendanceStatus'] = this.attendanceStatus
    return data
  }
}

export interface IUpdateMembershipAttendanceStatusCommand {
  id?: string
  attendanceStatus?: number
}

export class UpdateMembershipAttendanceStatusCommand
  implements IUpdateMembershipAttendanceStatusCommand {
  id?: string
  attendanceStatus?: number

  constructor(data?: IUpdateMembershipAttendanceStatusCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.attendanceStatus = _data['AttendanceStatus']
    }
  }

  static fromJS(data: any): UpdateMembershipAttendanceStatusCommand {
    data = typeof data === 'object' ? data : {}
    let result = new UpdateMembershipAttendanceStatusCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['AttendanceStatus'] = this.attendanceStatus
    return data
  }
}

export class ListEliteMentorSessionsViewModel implements IListEliteMentorSessionsViewModel {
  id?: string
  name?: string | undefined
  date?: Date | undefined
  mentorId?: string
  mentorName?: string | undefined
  mentorProfilePicture?: string | undefined

  constructor(data?: IListEliteMentorSessionsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined
      this.mentorId = _data['mentorId']
      this.mentorName = _data['mentorName']
      this.mentorProfilePicture = _data['mentorProfilePicture']
    }
  }

  static fromJS(data: any): ListEliteMentorSessionsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListEliteMentorSessionsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['mentorId'] = this.mentorId
    data['mentorName'] = this.mentorName
    data['mentorProfilePicture'] = this.mentorProfilePicture
    return data
  }
}

export interface IListEliteMentorSessionsViewModel {
  id?: string
  name?: string | undefined
  date?: Date | undefined
  mentorId?: string
  mentorName?: string | undefined
  mentorProfilePicture?: string | undefined
}

export class UpdateEliteMentorSessionCommand implements IUpdateEliteMentorSessionCommand {
  eliteMentorSessionId?: string
  date?: Date

  constructor(data?: IUpdateEliteMentorSessionCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.eliteMentorSessionId = _data['eliteMentorSessionId']
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined
    }
  }

  static fromJS(data: any): UpdateEliteMentorSessionCommand {
    data = typeof data === 'object' ? data : {}
    let result = new UpdateEliteMentorSessionCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['eliteMentorSessionId'] = this.eliteMentorSessionId
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    return data
  }
}

export interface IUpdateEliteMentorSessionCommand {
  eliteMentorSessionId?: string
  date?: Date
}

export class Mentor implements IMentor {
  id?: string
  name?: string
  aboutMentor?: string
  email?: string
  nationality?: string
  nationalityName?: string
  education?: string
  jobPosition?: string
  residenceCountry?: string
  residenceCountryName?: string
  pictureUrl?: string
  linkedIn?: string

  constructor(data?: IUpdateEliteMentorSessionCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.aboutMentor = _data['aboutMentor']
      this.email = _data['email']
      this.nationality = _data['nationality']
      this.nationalityName = _data['nationalityName']
      this.education = _data['education']
      this.jobPosition = _data['jobPosition']
      this.residenceCountry = _data['residenceCountry']
      this.residenceCountryName = _data['residenceCountryName']
      this.pictureUrl = _data['pictureUrl']
      this.linkedIn = _data['linkedIn']
    }
  }

  static fromJS(data: any): UpdateEliteMentorSessionCommand {
    data = typeof data === 'object' ? data : {}
    let result = new UpdateEliteMentorSessionCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['aboutMentor'] = this.aboutMentor
    data['email'] = this.email
    data['nationality'] = this.nationality
    data['nationalityName'] = this.nationalityName
    data['education'] = this.education
    data['jobPosition'] = this.jobPosition
    data['residenceCountry'] = this.residenceCountry
    data['residenceCountryName'] = this.residenceCountryName
    data['pictureUrl'] = this.pictureUrl
    data['linkedIn'] = this.linkedIn
    return data
  }
}

export interface IMentor {
  id?: string
  name?: string
  aboutMentor?: string
  email?: string
  nationality?: string
  nationalityName?: string
  education?: string
  jobPosition?: string
  residenceCountry?: string
  residenceCountryName?: string
  pictureUrl?: string
  linkedIn?: string
}

export class ListInstructorProjectsViewModel implements IListInstructorProjectsViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  applicantName?: string | undefined
  attachmentUrl?: string | undefined

  constructor(data?: IListInstructorProjectsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.topic = _data['topic']
      this.topic_Ar = _data['topic_Ar']
      this.description = _data['description']
      this.description_Ar = _data['description_Ar']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined
      this.applicantName = _data['applicantName']
      this.attachmentUrl = _data['attachmentUrl']
    }
  }

  static fromJS(data: any): ListInstructorProjectsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListInstructorProjectsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['topic'] = this.topic
    data['topic_Ar'] = this.topic_Ar
    data['description'] = this.description
    data['description_Ar'] = this.description_Ar
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['applicantName'] = this.applicantName
    data['attachmentUrl'] = this.attachmentUrl
    return data
  }
}

export interface IListInstructorProjectsViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  applicantName?: string | undefined
  attachmentUrl?: string | undefined
}

export class ListUserEducationQualificationsViewModel
  implements IListUserEducationQualificationsViewModel {
  id?: string
  city?: string | undefined
  university?: string | undefined
  university_AR?: string | undefined
  specialization?: string | undefined
  specialization_AR?: string | undefined
  degree?: number
  country?: string | undefined
  graduationDate?: Date

  constructor(data?: IListUserEducationQualificationsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.city = _data['city']
      this.university = _data['university']
      this.university_AR = _data['university_AR']
      this.specialization = _data['specialization']
      this.specialization_AR = _data['specialization_AR']
      this.degree = _data['degree']
      this.country = _data['country']
      this.graduationDate = _data['graduationDate']
        ? new Date(_data['graduationDate'].toString())
        : <any>undefined
    }
  }

  static fromJS(data: any): ListUserEducationQualificationsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserEducationQualificationsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['city'] = this.city
    data['university'] = this.university
    data['university_AR'] = this.university_AR
    data['specialization'] = this.specialization
    data['specialization_AR'] = this.specialization_AR
    data['degree'] = this.degree
    data['country'] = this.country
    data['graduationDate'] = this.graduationDate
      ? this.graduationDate.toISOString()
      : <any>undefined
    return data
  }
}

export interface IListUserEducationQualificationsViewModel {
  id?: string
  city?: string | undefined
  university?: string | undefined
  university_AR?: string | undefined
  specialization?: string | undefined
  specialization_AR?: string | undefined
  degree?: number
  country?: string | undefined
  graduationDate?: Date
}

export class UpdateUniversityCommand implements IUpdateUniversityCommand {
  id?: string
  name?: string | undefined
  phone?: string | undefined
  email?: string | undefined
  aboutUniversity?: string | undefined
  city?: string | undefined
  country?: string | undefined
  address?: string | undefined
  instagram?: string | undefined
  linkedIn?: string | undefined
  pOBox?: string | undefined
  twitter?: string | undefined
  website?: string | undefined

  constructor(data?: IUpdateUniversityCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.phone = _data['Phone']
      this.email = _data['Email']
      this.aboutUniversity = _data['AboutUniversity']
      this.city = _data['City']
      this.country = _data['Country']
      this.address = _data['Address']
      this.instagram = _data['Instagram']
      this.linkedIn = _data['LinkedIn']
      this.pOBox = _data['POBox']
      this.twitter = _data['Twitter']
      this.website = _data['Website']
    }
  }

  static fromJS(data: any): UpdateUniversityCommand {
    data = typeof data === 'object' ? data : {}
    let result = new UpdateUniversityCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Phone'] = this.phone
    data['Email'] = this.email
    data['AboutUniversity'] = this.aboutUniversity
    data['City'] = this.city
    data['Country'] = this.country
    data['Address'] = this.address
    data['Instagram'] = this.instagram
    data['LinkedIn'] = this.linkedIn
    data['POBox'] = this.pOBox
    data['Twitter'] = this.twitter
    data['Website'] = this.website
    return data
  }
}

export interface IUpdateUniversityCommand {
  id?: string
  name?: string | undefined
  phone?: string | undefined
  email?: string | undefined
  aboutUniversity?: string | undefined
  city?: string | undefined
  country?: string | undefined
  address?: string | undefined
  instagram?: string | undefined
  linkedIn?: string | undefined
  pOBox?: string | undefined
  twitter?: string | undefined
  website?: string | undefined
}

export class AddEducationQualificationCommand implements IAddEducationQualificationCommand {
  contactId?: string
  university?: string | undefined
  city?: string | undefined
  university_AR?: string | undefined
  specialization?: string | undefined
  specialization_AR?: string | undefined
  degree?: number
  graduationDate?: Date
  country?: string | undefined

  constructor(data?: IAddEducationQualificationCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.contactId = _data['contactId']
      this.university = _data['university']
      this.city = _data['city']
      this.university_AR = _data['university_AR']
      this.specialization = _data['specialization']
      this.specialization_AR = _data['specialization_AR']
      this.degree = _data['degree']
      this.graduationDate = _data['graduationDate']
        ? new Date(_data['graduationDate'].toString())
        : <any>undefined
      this.country = _data['country']
    }
  }

  static fromJS(data: any): AddEducationQualificationCommand {
    data = typeof data === 'object' ? data : {}
    let result = new AddEducationQualificationCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['contactId'] = this.contactId
    data['university'] = this.university
    data['city'] = this.city
    data['university_AR'] = this.university_AR
    data['specialization'] = this.specialization
    data['specialization_AR'] = this.specialization_AR
    data['degree'] = this.degree
    data['graduationDate'] = this.graduationDate
      ? this.graduationDate.toISOString()
      : <any>undefined
    data['country'] = this.country
    return data
  }
}

export interface IAddEducationQualificationCommand {
  contactId?: string
  university?: string | undefined
  city?: string | undefined
  university_AR?: string | undefined
  specialization?: string | undefined
  specialization_AR?: string | undefined
  degree?: number
  graduationDate?: Date
  country?: string | undefined
}

export class EditInstructorProjectCommand implements IEditInstructorProjectCommand {
  id?: string
  name?: string | undefined
  name_Ar?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined

  constructor(data?: IEditInstructorProjectCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_Ar = _data['name_Ar']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
    }
  }

  static fromJS(data: any): EditInstructorProjectCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditInstructorProjectCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_Ar'] = this.name_Ar
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    return data
  }
}

export interface IEditInstructorProjectCommand {
  id?: string
  name?: string | undefined
  name_Ar?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
}

export class ListGroupProjectsViewModel implements IListGroupProjectsViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  presentationDate?: Date | undefined
  projectStatus?: number
  type?: number
  moduleId?: string
  moduleName?: string | undefined
  attachmentUrl?: string | undefined
  isParent?: boolean
  topicId?: string
  topicName?: string | undefined
  programId?: string

  constructor(data?: IListGroupProjectsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.topic = _data['Topic']
      this.topic_Ar = _data['Topic_Ar']
      this.description = _data['Description']
      this.description_Ar = _data['Description_Ar']
      this.startDate = _data['StartDate'] ? new Date(_data['StartDate'].toString()) : <any>undefined
      this.endDate = _data['EndDate'] ? new Date(_data['EndDate'].toString()) : <any>undefined
      this.presentationDate = _data['PresentationDate']
        ? new Date(_data['PresentationDate'].toString())
        : <any>undefined
      this.projectStatus = _data['ProjectStatus']
      this.type = _data['Type']
      this.moduleId = _data['ModuleId']
      this.moduleName = _data['ModuleName']
      this.attachmentUrl = _data['AttachmentUrl']
      this.isParent = _data['IsParent']
      this.topicId = _data['TopicId']
      this.topicName = _data['TopicName']
      this.programId = _data['ProgramId']
    }
  }

  static fromJS(data: any): ListGroupProjectsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListGroupProjectsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Topic'] = this.topic
    data['Topic_Ar'] = this.topic_Ar
    data['Description'] = this.description
    data['Description_Ar'] = this.description_Ar
    data['StartDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['EndDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['PresentationDate'] = this.presentationDate
      ? this.presentationDate.toISOString()
      : <any>undefined
    data['ProjectStatus'] = this.projectStatus
    data['Type'] = this.type
    data['ModuleId'] = this.moduleId
    data['ModuleName'] = this.moduleName
    data['AttachmentUrl'] = this.attachmentUrl
    data['IsParent'] = this.isParent
    data['TopicId'] = this.topicId
    data['TopicName'] = this.topicName
    data['ProgramId'] = this.programId
    return data
  }
}

export interface IListGroupProjectsViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  presentationDate?: Date | undefined
  projectStatus?: number
  type?: number
  moduleId?: string
  moduleName?: string | undefined
  attachmentUrl?: string | undefined
  isParent?: boolean
  topicId?: string
  topicName?: string | undefined
  programId?: string
}

export class EditApplicantProjectCommand implements IEditApplicantProjectCommand {
  id?: string
  name?: string | undefined
  name_Ar?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  status?: number

  constructor(data?: IEditApplicantProjectCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_Ar = _data['name_Ar']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.status = _data['status']
    }
  }

  static fromJS(data: any): EditApplicantProjectCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditApplicantProjectCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_Ar'] = this.name_Ar
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['status'] = this.status
    return data
  }
}

export interface IEditApplicantProjectCommand {
  id?: string
  name?: string | undefined
  name_Ar?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  status?: number
}

export class ListTeamMembersViewModel implements IListTeamMembersViewModel {
  id?: string
  name?: string | undefined
  universityId?: string
  universityName?: string | undefined
  jobPosition?: string | undefined
  pictureUrl?: string | undefined
  email?: string | undefined
  aboutMember?: string | undefined
  linkedIn?: string | undefined

  constructor(data?: IListTeamMembersViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.universityId = _data['UniversityId']
      this.universityName = _data['UniversityName']
      this.jobPosition = _data['JobPosition']
      this.pictureUrl = _data['PictureUrl']
      this.email = _data['Email']
      this.aboutMember = _data['AboutMember']
      this.linkedIn = _data['LinkedIn']
    }
  }

  static fromJS(data: any): ListTeamMembersViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListTeamMembersViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['UniversityId'] = this.universityId
    data['UniversityName'] = this.universityName
    data['JobPosition'] = this.jobPosition
    data['PictureUrl'] = this.pictureUrl
    data['Email'] = this.email
    data['AboutMember'] = this.aboutMember
    data['LinkedIn'] = this.linkedIn
    return data
  }
}

export interface IListTeamMembersViewModel {
  id?: string
  name?: string | undefined
  universityId?: string
  universityName?: string | undefined
  jobPosition?: string | undefined
  pictureUrl?: string | undefined
  email?: string | undefined
  aboutMember?: string | undefined
  linkedIn?: string | undefined
}

export class ListProjectIdeasViewModel implements IListProjectIdeasViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  date?: Date | undefined
  alumniId?: string
  alumniName?: string | undefined
  budget?: number
  documentUrl?: string | undefined

  constructor(data?: IListProjectIdeasViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.description = _data['Description']
      this.date = _data['Date'] ? new Date(_data['Date'].toString()) : <any>undefined
      this.alumniId = _data['AlumniId']
      this.alumniName = _data['AlumniName']
      this.budget = _data['Budget']
      this.documentUrl = _data['DocumentUrl']
    }
  }

  static fromJS(data: any): ListProjectIdeasViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListProjectIdeasViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Description'] = this.description
    data['Date'] = this.date ? this.date.toISOString() : <any>undefined
    data['AlumniId'] = this.alumniId
    data['AlumniName'] = this.alumniName
    data['Budget'] = this.budget
    data['DocumentUrl'] = this.documentUrl
    return data
  }
}

export interface IListProjectIdeasViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  date?: Date | undefined
  alumniId?: string
  alumniName?: string | undefined
  budget?: number
  documentUrl?: string | undefined
}

export class EditEducationQualificationCommand implements IEditEducationQualificationCommand {
  id?: string
  university?: string | undefined
  city?: string | undefined
  university_AR?: string | undefined
  specialization?: string | undefined
  specialization_AR?: string | undefined
  degree?: number
  graduationDate?: Date
  country?: string | undefined

  constructor(data?: IEditEducationQualificationCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.university = _data['university']
      this.city = _data['city']
      this.university_AR = _data['university_AR']
      this.specialization = _data['specialization']
      this.specialization_AR = _data['specialization_AR']
      this.degree = _data['degree']
      this.graduationDate = _data['graduationDate']
        ? new Date(_data['graduationDate'].toString())
        : <any>undefined
      this.country = _data['country']
    }
  }

  static fromJS(data: any): EditEducationQualificationCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditEducationQualificationCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['university'] = this.university
    data['city'] = this.city
    data['university_AR'] = this.university_AR
    data['specialization'] = this.specialization
    data['specialization_AR'] = this.specialization_AR
    data['degree'] = this.degree
    data['graduationDate'] = this.graduationDate
      ? this.graduationDate.toISOString()
      : <any>undefined
    data['country'] = this.country
    return data
  }
}

export interface IEditEducationQualificationCommand {
  id?: string
  university?: string | undefined
  city?: string | undefined
  university_AR?: string | undefined
  specialization?: string | undefined
  specialization_AR?: string | undefined
  degree?: number
  graduationDate?: Date
  country?: string | undefined
}

export class ListAllProgramsViewModel implements IListAllProgramsViewModel {
  id?: string
  name?: string | undefined

  constructor(data?: IListAllProgramsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
    }
  }

  static fromJS(data: any): ListAllProgramsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListAllProgramsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    return data
  }
}

export interface IListAllProgramsViewModel {
  id?: string
  name?: string | undefined
}

export class SetProjectApprovalCommand implements ISetProjectApprovalCommand {
  id?: string

  constructor(data?: ISetProjectApprovalCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
    }
  }

  static fromJS(data: any): SetProjectApprovalCommand {
    data = typeof data === 'object' ? data : {}
    let result = new SetProjectApprovalCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    return data
  }
}

export interface ISetProjectApprovalCommand {
  id?: string
}

export class ListEnrollmentByUserIdViewModel implements IListEnrollmentByUserIdViewModel {
  id?: string
  status?: string | undefined

  constructor(data?: IListEnrollmentByUserIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.status = _data['status']
    }
  }

  static fromJS(data: any): ListEnrollmentByUserIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListEnrollmentByUserIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['status'] = this.status
    return data
  }
}

export interface IListEnrollmentByUserIdViewModel {
  id?: string
  status?: string | undefined
}

export class ListApplicantCompletedProjectsViewModel
  implements IListApplicantCompletedProjectsViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  projectStatus?: number
  type?: number
  moduleId?: string
  moduleName?: string | undefined
  attachmentUrl?: string | undefined

  constructor(data?: IListApplicantCompletedProjectsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.topic = _data['topic']
      this.topic_Ar = _data['topic_Ar']
      this.description = _data['description']
      this.description_Ar = _data['description_Ar']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined
      this.projectStatus = _data['projectStatus']
      this.type = _data['type']
      this.moduleId = _data['moduleId']
      this.moduleName = _data['moduleName']
      this.attachmentUrl = _data['attachmentUrl']
    }
  }

  static fromJS(data: any): ListApplicantCompletedProjectsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListApplicantCompletedProjectsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['topic'] = this.topic
    data['topic_Ar'] = this.topic_Ar
    data['description'] = this.description
    data['description_Ar'] = this.description_Ar
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['projectStatus'] = this.projectStatus
    data['type'] = this.type
    data['moduleId'] = this.moduleId
    data['moduleName'] = this.moduleName
    data['attachmentUrl'] = this.attachmentUrl
    return data
  }
}

export interface IListApplicantCompletedProjectsViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  projectStatus?: number
  type?: number
  moduleId?: string
  moduleName?: string | undefined
  attachmentUrl?: string | undefined
}

export class AddEnrollmentCommand implements IAddEnrollmentCommand {
  id?: string
  programId?: string

  constructor(data?: IAddEnrollmentCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.programId = _data['programId']
    }
  }

  static fromJS(data: any): AddEnrollmentCommand {
    data = typeof data === 'object' ? data : {}
    let result = new AddEnrollmentCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['programId'] = this.programId
    return data
  }
}

export interface IAddEnrollmentCommand {
  id?: string
  programId?: string
}

export class GetEnrollmentByIdViewModel implements IGetEnrollmentByIdViewModel {
  id?: string
  status?: string | undefined
  pymetricsUrl?: string | undefined
  pymetricsCompleted?: boolean | undefined

  constructor(data?: IGetEnrollmentByIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.status = _data['status']
      this.pymetricsUrl = _data['pymetricsUrl']
      this.pymetricsCompleted = _data['pymetricsCompleted']
    }
  }

  static fromJS(data: any): GetEnrollmentByIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetEnrollmentByIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['status'] = this.status
    data['pymetricsUrl'] = this.pymetricsUrl
    data['pymetricsCompleted'] = this.pymetricsCompleted
    return data
  }
}

export interface IGetEnrollmentByIdViewModel {
  id?: string
  status?: string | undefined
  pymetricsUrl?: string | undefined
  pymetricsCompleted?: boolean | undefined
}

export class GetActiveProgramViewModel implements IGetActiveProgramViewModel {
  id?: string
  name?: string | undefined

  constructor(data?: IGetActiveProgramViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
    }
  }

  static fromJS(data: any): GetActiveProgramViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetActiveProgramViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    return data
  }
}

export interface IGetActiveProgramViewModel {
  id?: string
  name?: string | undefined
}

export class ApiProblemDetails implements IApiProblemDetails {
  readonly errors?: any[] | undefined
  type?: string | undefined
  title?: string | undefined
  status?: number | undefined
  detail?: string | undefined
  instance?: string | undefined

  constructor(data?: IApiProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['errors'])) {
        ; (<any>this).errors = [] as any
        for (let item of _data['errors']) (<any>this).errors!.push(item)
      }
      this.type = _data['type']
      this.title = _data['title']
      this.status = _data['status']
      this.detail = _data['detail']
      this.instance = _data['instance']
    }
  }

  static fromJS(data: any): ApiProblemDetails {
    data = typeof data === 'object' ? data : {}
    let result = new ApiProblemDetails()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    if (Array.isArray(this.errors)) {
      data['errors'] = []
      for (let item of this.errors) data['errors'].push(item)
    }
    data['type'] = this.type
    data['title'] = this.title
    data['status'] = this.status
    data['detail'] = this.detail
    data['instance'] = this.instance
    return data
  }
}

export interface IApiProblemDetails {
  errors?: any[] | undefined
  type?: string | undefined
  title?: string | undefined
  status?: number | undefined
  detail?: string | undefined
  instance?: string | undefined
}

export class ListTeamMembersByModuleIdViewModel implements IListTeamMembersByModuleIdViewModel {
  id?: string
  name?: string | undefined
  universityId?: string
  universityName?: string | undefined
  jobPosition?: string | undefined
  pictureUrl?: string | undefined

  constructor(data?: IListTeamMembersByModuleIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.universityId = _data['UniversityId']
      this.universityName = _data['UniversityName']
      this.jobPosition = _data['JobPosition']
      this.pictureUrl = _data['PictureUrl']
    }
  }

  static fromJS(data: any): ListTeamMembersByModuleIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListTeamMembersByModuleIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['UniversityId'] = this.universityId
    data['UniversityName'] = this.universityName
    data['JobPosition'] = this.jobPosition
    data['PictureUrl'] = this.pictureUrl
    return data
  }
}

export interface IListTeamMembersByModuleIdViewModel {
  id?: string
  name?: string | undefined
  universityId?: string
  universityName?: string | undefined
  jobPosition?: string | undefined
  pictureUrl?: string | undefined
}

export class ListProgramAnswersByEnrollmentIdViewModel
  implements IListProgramAnswersByEnrollmentIdViewModel {
  questionId?: string
  answerText?: string | undefined

  constructor(data?: IListProgramAnswersByEnrollmentIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.questionId = _data['questionId']
      this.answerText = _data['answerText']
    }
  }

  static fromJS(data: any): ListProgramAnswersByEnrollmentIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListProgramAnswersByEnrollmentIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['questionId'] = this.questionId
    data['answerText'] = this.answerText
    return data
  }
}

export interface IListProgramAnswersByEnrollmentIdViewModel {
  questionId?: string
  answerText?: string | undefined
}

export class ListAlumniAvailableProgramViewModel implements IListAlumniAvailableProgramViewModel {
  id?: string
  name?: string | undefined
  desription?: string | undefined
  name_AR?: string | undefined
  desription_AR?: string | undefined
  pictureUrl?: string | undefined

  constructor(data?: IListAlumniAvailableProgramViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.desription = _data['Desription']
      this.name_AR = _data['Name']
      this.desription_AR = _data['Desription_AR']
      this.pictureUrl = _data['PictureUrl']
    }
  }

  static fromJS(data: any): ListAlumniAvailableProgramViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListAlumniAvailableProgramViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Desription'] = this.desription
    data['PictureUrl'] = this.pictureUrl
    return data
  }
}

export interface IListAlumniAvailableProgramViewModel {
  id?: string
  name?: string | undefined
  desription?: string | undefined
  pictureUrl?: string | undefined
}

export class AnswerForUpsertDto implements IAnswerForUpsertDto {
  questionId?: string
  answerText?: string | undefined

  constructor(data?: IAnswerForUpsertDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.questionId = _data['questionId']
      this.answerText = _data['answerText']
    }
  }

  static fromJS(data: any): AnswerForUpsertDto {
    data = typeof data === 'object' ? data : {}
    let result = new AnswerForUpsertDto()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['questionId'] = this.questionId
    data['answerText'] = this.answerText
    return data
  }
}

export interface IAnswerForUpsertDto {
  questionId?: string
  answerText?: string | undefined
}

export class AnswerForEventsDto implements IAnswerForEventsDto {
  Answer?: string
  EventQuestionId?: string

  constructor(data?: IAnswerForEventsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Answer = _data['Answer']
      this.EventQuestionId = _data['EventQuestionId']
    }
  }

  static fromJS(data: any): AnswerForUpsertDto {
    data = typeof data === 'object' ? data : {}
    let result = new AnswerForUpsertDto()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Answer'] = this.Answer
    data['EventQuestionId'] = this.EventQuestionId
    return data
  }
}

export interface IAnswerForEventsDto {
  Answer?: string
  EventQuestionId?: string
}

export class ListAlumniGraduatedProgramViewModel implements IListAlumniGraduatedProgramViewModel {
  programId?: string
  cohortId?: string
  programName?: string | undefined
  programDescription?: string | undefined
  programName_AR?: string | undefined
  programDescription_AR?: string | undefined
  cohortYear?: number | undefined
  pictureUrl?: string | undefined

  constructor(data?: IListAlumniGraduatedProgramViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.programId = _data['ProgramId']
      this.cohortId = _data['CohortId']
      this.programName = _data['ProgramName']
      this.programName_AR = _data['ProgramName_AR']
      this.programDescription_AR = _data['ProgramDescription_AR']
      this.programDescription = _data['ProgramDescription']
      this.cohortYear = _data['CohortYear']
      this.pictureUrl = _data['PictureUrl']
    }
  }

  static fromJS(data: any): ListAlumniGraduatedProgramViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListAlumniGraduatedProgramViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['ProgramId'] = this.programId
    data['CohortId'] = this.cohortId
    data['ProgramName'] = this.programName
    data['ProgramDescription'] = this.programDescription
    data['CohortYear'] = this.cohortYear
    data['PictureUrl'] = this.pictureUrl
    return data
  }
}

export interface IListAlumniGraduatedProgramViewModel {
  programId?: string
  cohortId?: string
  programName?: string | undefined
  programDescription?: string | undefined
  cohortYear?: number | undefined
  pictureUrl?: string | undefined
}

export class GetEnrollmentStatusByIdViewModel implements IGetEnrollmentStatusByIdViewModel {
  isAchievementStepCompleted?: boolean
  isReferenceStepCompleted?: boolean
  isQuestionStepCompleted?: boolean
  isSmartAssessmentStepCompleted?: boolean
  isAcknowledgmentStepCompleted?: boolean

  constructor(data?: IGetEnrollmentStatusByIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isAchievementStepCompleted = _data['isAchievementStepCompleted']
      this.isReferenceStepCompleted = _data['isReferenceStepCompleted']
      this.isQuestionStepCompleted = _data['isQuestionStepCompleted']
      this.isSmartAssessmentStepCompleted = _data['isSmartAssessmentStepCompleted']
      this.isAcknowledgmentStepCompleted = _data['isAcknowledgmentStepCompleted']
    }
  }

  static fromJS(data: any): GetEnrollmentStatusByIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetEnrollmentStatusByIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['isAchievementStepCompleted'] = this.isAchievementStepCompleted
    data['isReferenceStepCompleted'] = this.isReferenceStepCompleted
    data['isQuestionStepCompleted'] = this.isQuestionStepCompleted
    data['isSmartAssessmentStepCompleted'] = this.isSmartAssessmentStepCompleted
    data['isAcknowledgmentStepCompleted'] = this.isAcknowledgmentStepCompleted
    return data
  }
}

export interface IGetEnrollmentStatusByIdViewModel {
  isAchievementStepCompleted?: boolean
  isReferenceStepCompleted?: boolean
  isQuestionStepCompleted?: boolean
  isSmartAssessmentStepCompleted?: boolean
  isAcknowledgmentStepCompleted?: boolean
}

export class ListTopicsByProgramIdViewModel implements IListTopicsByProgramIdViewModel {
  id?: string
  topicName?: string | undefined

  constructor(data?: IListTopicsByProgramIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.topicName = _data['TopicName']
    }
  }

  static fromJS(data: any): ListTopicsByProgramIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListTopicsByProgramIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['TopicName'] = this.topicName
    return data
  }
}

export interface IListTopicsByProgramIdViewModel {
  id?: string
  topicName?: string | undefined
}

export class SearchProjectIdeasViewModel implements ISearchProjectIdeasViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  body?: string | undefined
  projectIdeaStatus?: number
  date?: Date | undefined
  alumniId?: string
  alumniName?: string | undefined
  budget?: number
  documentUrl?: string | undefined

  constructor(data?: ISearchProjectIdeasViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.description = _data['Description']
      this.body = _data['Body']
      this.projectIdeaStatus = _data['ProjectIdeaStatus']
      this.date = _data['Date'] ? new Date(_data['Date'].toString()) : <any>undefined
      this.alumniId = _data['AlumniId']
      this.alumniName = _data['AlumniName']
      this.budget = _data['Budget']
      this.documentUrl = _data['DocumentUrl']
    }
  }

  static fromJS(data: any): SearchProjectIdeasViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new SearchProjectIdeasViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Description'] = this.description
    data['Body'] = this.body
    data['ProjectIdeaStatus'] = this.projectIdeaStatus
    data['Date'] = this.date ? this.date.toISOString() : <any>undefined
    data['AlumniId'] = this.alumniId
    data['AlumniName'] = this.alumniName
    data['Budget'] = this.budget
    data['DocumentUrl'] = this.documentUrl
    return data
  }
}

export interface ISearchProjectIdeasViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  body?: string | undefined
  projectIdeaStatus?: number
  date?: Date | undefined
  alumniId?: string
  alumniName?: string | undefined
  budget?: number
  documentUrl?: string | undefined
}

export class ListEventsViewModel implements IListEventsViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  fromDate?: Date
  pictureUrl?: string | undefined
  toDate?: string | undefined

  constructor(data?: IListEventsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.description = _data['description']
      this.fromDate = _data['fromDate'] ? new Date(_data['fromDate'].toString()) : <any>undefined
      this.pictureUrl = _data['pictureUrl']
    }
  }

  static fromJS(data: any): ListEventsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListEventsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['description'] = this.description
    data['fromDate'] = this.fromDate ? this.fromDate.toISOString() : <any>undefined
    data['pictureUrl'] = this.pictureUrl
    return data
  }
}

export interface IListEventsViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  fromDate?: Date
  pictureUrl?: string | undefined
}

export class ListEventsRegistrationModel implements IListEventsRegistrationModel {
  eventId?: string | undefined
  name?: string | undefined
  registrant?: string | undefined
  statusCode?: Date

  constructor(data?: IListEventsRegistrationModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.eventId = _data['eventId']
      this.name = _data['name']
      this.registrant = _data['registrant']
      this.statusCode = _data['statusCode']
    }
  }

  static fromJS(data: any): ListEventsRegistrationModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListEventsRegistrationModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['eventId'] = this.eventId
    data['name'] = this.name
    data['registrant'] = this.registrant
    data['statusCode'] = this.statusCode
    return data
  }
}

export interface IListEventsRegistrationModel {
  eventId?: string | undefined
  name?: string | undefined
  registrant?: string | undefined
  statusCode?: Date
}



export class ListUserSurveysUrlViewModel implements IListUserSurveysUrlViewModel {
  name?: string | undefined
  surveyTemplateName?: string | undefined
  surveyURL?: string | undefined

  constructor(data?: IListUserSurveysUrlViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
      this.surveyTemplateName = _data['surveyTemplateName']
      this.surveyURL = _data['surveyURL']
    }
  }

  static fromJS(data: any): ListUserSurveysUrlViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserSurveysUrlViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Name'] = this.name
    data['SurveyTemplateName'] = this.surveyTemplateName
    data['SurveyURL'] = this.surveyURL
    return data
  }
}

export interface IListUserSurveysUrlViewModel {
  name?: string | undefined
  surveyTemplateName?: string | undefined
  surveyURL?: string | undefined
}

export class ListSurveysByProgramIdViewModel implements IListSurveysByProgramIdViewModel {
  name?: string | undefined
  surveyTemplateName?: string | undefined
  surveyURL?: string | undefined
  status?: number

  constructor(data?: IListSurveysByProgramIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
      this.surveyTemplateName = _data['surveyTemplateName']
      this.surveyURL = _data['surveyURL']
      this.status = _data['status']
    }
  }

  static fromJS(data: any): ListSurveysByProgramIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListSurveysByProgramIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['name'] = this.name
    data['surveyTemplateName'] = this.surveyTemplateName
    data['surveyURL'] = this.surveyURL
    data['status'] = this.status
    return data
  }
}

export interface IListSurveysByProgramIdViewModel {
  name?: string | undefined
  surveyTemplateName?: string | undefined
  surveyURL?: string | undefined
  status?: number
}

export class ListApplicantMeetingViewModel implements IListApplicantMeetingViewModel {
  id?: string
  name?: string | undefined
  startDate?: Date
  endDate?: Date
  duration?: number
  contactID?: string
  meetingId?: string
  meetingUrl?: string | undefined

  constructor(data?: IListApplicantMeetingViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.startDate = _data['StartDate'] ? new Date(_data['StartDate'].toString()) : <any>undefined
      this.endDate = _data['EndDate'] ? new Date(_data['EndDate'].toString()) : <any>undefined
      this.duration = _data['Duration']
      this.contactID = _data['ContactID']
      this.meetingId = _data['MeetingId']
      this.meetingUrl = _data['MeetingUrl']
    }
  }

  static fromJS(data: any): ListApplicantMeetingViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListApplicantMeetingViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['StartDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['EndDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['Duration'] = this.duration
    data['ContactID'] = this.contactID
    data['MeetingId'] = this.meetingId
    data['MeetingUrl'] = this.meetingUrl
    return data
  }
}

export interface IListApplicantMeetingViewModel {
  id?: string
  name?: string | undefined
  startDate?: Date
  endDate?: Date
  duration?: number
  contactID?: string
  meetingId?: string
  meetingUrl?: string | undefined
}

export class GetProjectByIdViewModel implements IGetProjectByIdViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  presentationDate?: Date | undefined
  projectStatus?: number
  type?: number
  moduleId?: string
  moduleName?: string | undefined
  attachmentUrl?: string | undefined
  topicId?: string
  topicName?: string | undefined
  programId?: string

  constructor(data?: IGetProjectByIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.topic = _data['Topic']
      this.topic_Ar = _data['Topic_Ar']
      this.description = _data['Description']
      this.description_Ar = _data['Description_Ar']
      this.startDate = _data['StartDate'] ? new Date(_data['StartDate'].toString()) : <any>undefined
      this.endDate = _data['EndDate'] ? new Date(_data['EndDate'].toString()) : <any>undefined
      this.presentationDate = _data['PresentationDate']
        ? new Date(_data['PresentationDate'].toString())
        : <any>undefined
      this.projectStatus = _data['ProjectStatus']
      this.type = _data['Type']
      this.moduleId = _data['ModuleId']
      this.moduleName = _data['ModuleName']
      this.attachmentUrl = _data['AttachmentUrl']
      this.topicId = _data['TopicId']
      this.topicName = _data['TopicName']
      this.programId = _data['ProgramId']
    }
  }

  static fromJS(data: any): GetProjectByIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetProjectByIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Topic'] = this.topic
    data['Topic_Ar'] = this.topic_Ar
    data['Description'] = this.description
    data['Description_Ar'] = this.description_Ar
    data['StartDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['EndDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['PresentationDate'] = this.presentationDate
      ? this.presentationDate.toISOString()
      : <any>undefined
    data['ProjectStatus'] = this.projectStatus
    data['Type'] = this.type
    data['ModuleId'] = this.moduleId
    data['ModuleName'] = this.moduleName
    data['AttachmentUrl'] = this.attachmentUrl
    data['TopicId'] = this.topicId
    data['TopicName'] = this.topicName
    data['ProgramId'] = this.programId
    return data
  }
}

export interface IGetProjectByIdViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  presentationDate?: Date | undefined
  projectStatus?: number
  type?: number
  moduleId?: string
  moduleName?: string | undefined
  attachmentUrl?: string | undefined
  topicId?: string
  topicName?: string | undefined
  programId?: string
}

export class AddEventRegistrantCommand implements IAddEventRegistrantCommand {
  id?: string
  eventId?: string

  constructor(data?: IAddEventRegistrantCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.eventId = _data['eventId']
    }
  }

  static fromJS(data: any): AddEventRegistrantCommand {
    data = typeof data === 'object' ? data : {}
    let result = new AddEventRegistrantCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['eventId'] = this.eventId
    return data
  }
}

export interface IAddEventRegistrantCommand {
  id?: string
  eventId?: string
}

export class ListUserLanguageSkillsViewModel implements IListUserLanguageSkillsViewModel {
  id?: string
  languageId?: string
  level?: number

  constructor(data?: IListUserLanguageSkillsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.languageId = _data['languageId']
      this.level = _data['level']
    }
  }

  static fromJS(data: any): ListUserLanguageSkillsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserLanguageSkillsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['languageId'] = this.languageId
    data['level'] = this.level
    return data
  }
}

export interface IListUserLanguageSkillsViewModel {
  id?: string
  languageId?: string
  level?: number
}

export class AddLanguageSkillCommand implements IAddLanguageSkillCommand {
  contactId?: string
  languageId?: string
  level?: number

  constructor(data?: IAddLanguageSkillCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.contactId = _data['contactId']
      this.languageId = _data['languageId']
      this.level = _data['level']
    }
  }

  static fromJS(data: any): AddLanguageSkillCommand {
    data = typeof data === 'object' ? data : {}
    let result = new AddLanguageSkillCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['contactId'] = this.contactId
    data['languageId'] = this.languageId
    data['level'] = this.level
    return data
  }
}

export interface IAddLanguageSkillCommand {
  contactId?: string
  languageId?: string
  level?: number
}

export class EditLanguageSkillCommand implements IEditLanguageSkillCommand {
  id?: string
  languageId?: string
  level?: number

  constructor(data?: IEditLanguageSkillCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.languageId = _data['languageId']
      this.level = _data['level']
    }
  }

  static fromJS(data: any): EditLanguageSkillCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditLanguageSkillCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['languageId'] = this.languageId
    data['level'] = this.level
    return data
  }
}

export interface IEditLanguageSkillCommand {
  id?: string
  languageId?: string
  level?: number
}

export class ListMaterialsByModuleIdViewModel implements IListMaterialsByModuleIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  duration?: number
  location?: string | undefined
  order?: number
  completed?: number | undefined
  startDate?: Date | undefined
  publishDate?: Date | undefined
  status?: number

  constructor(data?: IListMaterialsByModuleIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.duration = _data['duration']
      this.location = _data['location']
      this.order = _data['order']
      this.completed = _data['completed']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.publishDate = _data['publishDate']
        ? new Date(_data['publishDate'].toString())
        : <any>undefined
      this.status = _data['status']
    }
  }

  static fromJS(data: any): ListMaterialsByModuleIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListMaterialsByModuleIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['duration'] = this.duration
    data['location'] = this.location
    data['order'] = this.order
    data['completed'] = this.completed
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['publishDate'] = this.publishDate ? this.publishDate.toISOString() : <any>undefined
    data['status'] = this.status
    return data
  }
}

export interface IListMaterialsByModuleIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  duration?: number
  location?: string | undefined
  order?: number
  completed?: number | undefined
  startDate?: Date | undefined
  publishDate?: Date | undefined
  status?: number
}

export class GetMaterialByIdViewModel implements IGetMaterialByIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  location?: string | undefined
  duration?: number
  order?: number
  moduleId?: string
  startDate?: Date | undefined
  publishDate?: Date | undefined
  status?: number

  constructor(data?: IGetMaterialByIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.location = _data['location']
      this.duration = _data['duration']
      this.order = _data['order']
      this.moduleId = _data['moduleId']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.publishDate = _data['publishDate']
        ? new Date(_data['publishDate'].toString())
        : <any>undefined
      this.status = _data['status']
    }
  }

  static fromJS(data: any): GetMaterialByIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetMaterialByIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['location'] = this.location
    data['duration'] = this.duration
    data['order'] = this.order
    data['moduleId'] = this.moduleId
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['publishDate'] = this.publishDate ? this.publishDate.toISOString() : <any>undefined
    data['status'] = this.status
    return data
  }
}

export interface IGetMaterialByIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  location?: string | undefined
  duration?: number
  order?: number
  moduleId?: string
  startDate?: Date | undefined
  publishDate?: Date | undefined
  status?: number
}

export enum MaterialStatuses {
  Published = 1,
  Scheduled = 936510001,
  Draft = 936510000,
}

export class ListUserMembershipsViewModel implements IListUserMembershipsViewModel {
  id?: string
  completed?: boolean
  membershipLevel?: number
  name?: string | undefined
  institutionName?: string | undefined
  institutionName_AR?: string | undefined
  joinDate?: Date
  roleName?: string | undefined
  roleName_AR?: string | undefined
  active?: boolean

  constructor(data?: IListUserMembershipsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.institutionName = _data['institutionName']
      this.institutionName_AR = _data['institutionName_AR']
      this.joinDate = _data['joinDate'] ? new Date(_data['joinDate'].toString()) : <any>undefined
      this.roleName = _data['roleName']
      this.roleName_AR = _data['roleName_AR']
      this.active = _data['active']
      this.membershipLevel = _data['membershipLevel']
      this.completed = _data['completed']
    }
  }

  static fromJS(data: any): ListUserMembershipsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserMembershipsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['institutionName'] = this.institutionName
    data['institutionName_AR'] = this.institutionName_AR
    data['joinDate'] = this.joinDate ? this.joinDate.toISOString() : <any>undefined
    data['roleName'] = this.roleName
    data['roleName_AR'] = this.roleName_AR
    data['active'] = this.active
    data['membershipLevel'] = this.membershipLevel
    data['completed'] = this.completed
    return data
  }
}

export interface IListUserMembershipsViewModel {
  id?: string
  membershipLevel?: number
  name?: string | undefined
  institutionName?: string | undefined
  institutionName_AR?: string | undefined
  joinDate?: Date
  roleName?: string | undefined
  roleName_AR?: string | undefined
  active?: boolean
}

export class ListProjectsByCohortIdViewModel implements IListProjectsByCohortIdViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  projectStatus?: number
  type?: number
  attachmentUrl?: string | undefined

  constructor(data?: IListProjectsByCohortIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.topic = _data['Topic']
      this.topic_Ar = _data['Topic_Ar']
      this.description = _data['Description']
      this.description_Ar = _data['Description_Ar']
      this.startDate = _data['StartDate'] ? new Date(_data['StartDate'].toString()) : <any>undefined
      this.endDate = _data['EndDate'] ? new Date(_data['EndDate'].toString()) : <any>undefined
      this.projectStatus = _data['ProjectStatus']
      this.type = _data['Type']
      this.attachmentUrl = _data['AttachmentUrl']
    }
  }

  static fromJS(data: any): ListProjectsByCohortIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListProjectsByCohortIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Topic'] = this.topic
    data['Topic_Ar'] = this.topic_Ar
    data['Description'] = this.description
    data['Description_Ar'] = this.description_Ar
    data['StartDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['EndDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['ProjectStatus'] = this.projectStatus
    data['Type'] = this.type
    data['AttachmentUrl'] = this.attachmentUrl
    return data
  }
}

export interface IListProjectsByCohortIdViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  projectStatus?: number
  type?: number
  attachmentUrl?: string | undefined
}

export class AddMembershipCommand implements IAddMembershipCommand {
  institutionName?: string | undefined
  institutionName_AR?: string | undefined
  joinDate?: Date
  roleName?: string | undefined
  roleName_AR?: string | undefined
  active?: boolean | undefined
  contactId?: string
  membershipLevel?: number

  constructor(data?: IAddMembershipCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.institutionName = _data['institutionName']
      this.institutionName_AR = _data['institutionName_AR']
      this.joinDate = _data['joinDate'] ? new Date(_data['joinDate'].toString()) : <any>undefined
      this.roleName = _data['roleName']
      this.roleName_AR = _data['roleName_AR']
      this.active = _data['active']
      this.contactId = _data['contactId']
      this.membershipLevel = _data['membershipLevel']
    }
  }

  static fromJS(data: any): AddMembershipCommand {
    data = typeof data === 'object' ? data : {}
    let result = new AddMembershipCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['institutionName'] = this.institutionName
    data['institutionName_AR'] = this.institutionName_AR
    data['joinDate'] = this.joinDate ? this.joinDate.toISOString() : <any>undefined
    data['roleName'] = this.roleName
    data['roleName_AR'] = this.roleName_AR
    data['active'] = this.active
    data['contactId'] = this.contactId
    data['membershipLevel'] = this.membershipLevel
    return data
  }
}

export interface IAddMembershipCommand {
  institutionName?: string | undefined
  institutionName_AR?: string | undefined
  joinDate?: Date
  roleName?: string | undefined
  roleName_AR?: string | undefined
  active?: boolean | undefined
  contactId?: string
  membershipLevel?: number
}

export class EditMembershipCommand implements IEditMembershipCommand {
  id?: string
  membershipLevel?: number
  institutionName?: string | undefined
  institutionName_AR?: string | undefined
  joinDate?: Date
  roleName?: string | undefined
  roleName_AR?: string | undefined
  active?: boolean | undefined

  constructor(data?: IEditMembershipCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.institutionName = _data['institutionName']
      this.institutionName_AR = _data['institutionName_AR']
      this.joinDate = _data['joinDate'] ? new Date(_data['joinDate'].toString()) : <any>undefined
      this.roleName = _data['roleName']
      this.roleName_AR = _data['roleName_AR']
      this.active = _data['active']
      this.membershipLevel = _data['membershipLevel']
    }
  }

  static fromJS(data: any): EditMembershipCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditMembershipCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['institutionName'] = this.institutionName
    data['institutionName_AR'] = this.institutionName_AR
    data['joinDate'] = this.joinDate ? this.joinDate.toISOString() : <any>undefined
    data['roleName'] = this.roleName
    data['roleName_AR'] = this.roleName_AR
    data['active'] = this.active
    data['membershipLevel'] = this.membershipLevel
    return data
  }
}

export interface IEditMembershipCommand {
  id?: string
  membershipLevel?: number
  institutionName?: string | undefined
  institutionName_AR?: string | undefined
  joinDate?: Date
  roleName?: string | undefined
  roleName_AR?: string | undefined
  active?: boolean | undefined
}

export class ListIndustriesViewModel implements IListIndustriesViewModel {
  id?: string | undefined
  label?: string | undefined

  constructor(data?: IListIndustriesViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.label = _data['label']
    }
  }

  static fromJS(data: any): ListIndustriesViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListIndustriesViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['label'] = this.label
    return data
  }
}

export interface IListIndustriesViewModel {
  id?: string | undefined
  label?: string | undefined
}

export class ListSectorsViewModel implements IListSectorsViewModel {
  id?: string
  label?: string | undefined

  constructor(data?: IListSectorsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.label = _data['label']
    }
  }

  static fromJS(data: any): ListSectorsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListSectorsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['label'] = this.label
    return data
  }
}

export interface IListSectorsViewModel {
  id?: string
  label?: string | undefined
}

export class GetApplicantProfileViewModel implements IGetApplicantProfileViewModel {
  id?: string
  name?: string | undefined
  email?: string | undefined
  mobile?: string | undefined
  businessEmail?: string | undefined
  nationality?: string | undefined
  residenceCountry?: string | undefined
  linkedInUrl?: string | undefined
  profilePictureUrl?: string | undefined
  jobTitle?: string | undefined
  organization?: string | undefined
  education?: string | undefined

  constructor(data?: IGetApplicantProfileViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.email = _data['Email']
      this.mobile = _data['Mobile']
      this.businessEmail = _data['BusinessEmail']
      this.nationality = _data['Nationality']
      this.residenceCountry = _data['ResidenceCountry']
      this.linkedInUrl = _data['LinkedInUrl']
      this.profilePictureUrl = _data['ProfilePictureUrl']
      this.jobTitle = _data['JobTitle']
      this.organization = _data['Organization']
      this.education = _data['Education']
    }
  }

  static fromJS(data: any): GetApplicantProfileViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetApplicantProfileViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Email'] = this.email
    data['Mobile'] = this.mobile
    data['BusinessEmail'] = this.businessEmail
    data['Nationality'] = this.nationality
    data['ResidenceCountry'] = this.residenceCountry
    data['LinkedInUrl'] = this.linkedInUrl
    data['ProfilePictureUrl'] = this.profilePictureUrl
    data['JobTitle'] = this.jobTitle
    data['Organization'] = this.organization
    data['Education'] = this.education
    return data
  }
}

export interface IGetApplicantProfileViewModel {
  id?: string
  name?: string | undefined
  email?: string | undefined
  mobile?: string | undefined
  businessEmail?: string | undefined
  nationality?: string | undefined
  residenceCountry?: string | undefined
  linkedInUrl?: string | undefined
  profilePictureUrl?: string | undefined
  jobTitle?: string | undefined
  organization?: string | undefined
  education?: string | undefined
}

export class GetUniversityProfileViewModel implements IGetUniversityProfileViewModel {
  id?: string
  name?: string | undefined
  phone?: string | undefined
  email?: string | undefined
  aboutUniversity?: string | undefined
  accessInstructorId?: string | undefined
  accessInstructorName?: string | undefined
  city?: string | undefined
  country?: string | undefined
  address?: string | undefined
  instagram?: string | undefined
  linkedIn?: string | undefined
  pOBox?: string | undefined
  twitter?: string | undefined
  website?: string | undefined

  constructor(data?: IGetUniversityProfileViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.phone = _data['Phone']
      this.email = _data['Email']
      this.aboutUniversity = _data['AboutUniversity']
      this.accessInstructorId = _data['AccessInstructorId']
      this.accessInstructorName = _data['AccessInstructorName']
      this.city = _data['City']
      this.country = _data['Country']
      this.address = _data['Address']
      this.instagram = _data['Instagram']
      this.linkedIn = _data['LinkedIn']
      this.pOBox = _data['POBox']
      this.twitter = _data['Twitter']
      this.website = _data['Website']
    }
  }

  static fromJS(data: any): GetUniversityProfileViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetUniversityProfileViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Phone'] = this.phone
    data['Email'] = this.email
    data['AboutUniversity'] = this.aboutUniversity
    data['AccessInstructorId'] = this.accessInstructorId
    data['AccessInstructorName'] = this.accessInstructorName
    data['City'] = this.city
    data['Country'] = this.country
    data['Address'] = this.address
    data['Instagram'] = this.instagram
    data['LinkedIn'] = this.linkedIn
    data['POBox'] = this.pOBox
    data['Twitter'] = this.twitter
    data['Website'] = this.website
    return data
  }
}

export interface IGetUniversityProfileViewModel {
  id?: string
  name?: string | undefined
  phone?: string | undefined
  email?: string | undefined
  aboutUniversity?: string | undefined
  accessInstructorId?: string | undefined
  accessInstructorName?: string | undefined
  city?: string | undefined
  country?: string | undefined
  address?: string | undefined
  instagram?: string | undefined
  linkedIn?: string | undefined
  pOBox?: string | undefined
  twitter?: string | undefined
  website?: string | undefined
}

export class ListDirectManagerApplicantsViewModel implements IListDirectManagerApplicantsViewModel {
  id?: string | undefined
  fullName?: string | undefined
  profilePictureUrl?: string | undefined

  constructor(data?: IListDirectManagerApplicantsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.fullName = _data['FullName']
      this.profilePictureUrl = _data['ProfilePictureUrl']
    }
  }

  static fromJS(data: any): ListDirectManagerApplicantsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListDirectManagerApplicantsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['FullName'] = this.fullName
    data['ProfilePictureUrl'] = this.profilePictureUrl
    return data
  }
}

export interface IListDirectManagerApplicantsViewModel {
  id?: string | undefined
  fullName?: string | undefined
  profilePictureUrl?: string | undefined
}

export class ListLanguagesViewModel implements IListLanguagesViewModel {
  id?: string | undefined
  label?: string | undefined

  constructor(data?: IListLanguagesViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.label = _data['label']
    }
  }

  static fromJS(data: any): ListLanguagesViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListLanguagesViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['label'] = this.label
    return data
  }
}

export interface IListLanguagesViewModel {
  id?: string | undefined
  label?: string | undefined
}

export class ListModuleApplicantsViewModel implements IListModuleApplicantsViewModel {
  id?: string
  name?: string | undefined
  profilePictureUrl?: string | undefined

  constructor(data?: IListModuleApplicantsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.profilePictureUrl = _data['ProfilePictureUrl']
    }
  }

  static fromJS(data: any): ListModuleApplicantsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListModuleApplicantsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['ProfilePictureUrl'] = this.profilePictureUrl
    return data
  }
}

export interface IListModuleApplicantsViewModel {
  id?: string
  name?: string | undefined
  profilePictureUrl?: string | undefined
}
export class ListNewsFeedsViewModel implements IListNewsFeedsViewModel {
  id?: string | undefined
  name?: string | undefined
  duration?: number
  text?: string | undefined
  type?: number
  url?: string | undefined
  documentUrl?: string | undefined
  order?: number
  meetingStartDate?: Date | undefined
  moduleId?: string
  moduleName?: string | undefined
  instructorId?: string
  instructorName?: string | undefined
  profilePictureUrl?: string | undefined
  liked?: boolean
  likes?: number | undefined

  constructor(data?: IListNewsFeedsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.duration = _data['duration']
      this.text = _data['text']
      this.type = _data['type']
      this.url = _data['url']
      this.documentUrl = _data['documentUrl']
      this.order = _data['order']
      this.meetingStartDate = _data['meetingStartDate']
        ? new Date(_data['meetingStartDate'].toString())
        : <any>undefined
      this.moduleId = _data['moduleId']
      this.moduleName = _data['moduleName']
      this.instructorId = _data['instructorId']
      this.instructorName = _data['instructorName']
      this.profilePictureUrl = _data['profilePictureUrl']
      this.liked = _data['liked']
      this.likes = _data['likes']
    }
  }

  static fromJS(data: any): ListNewsFeedsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListNewsFeedsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['duration'] = this.duration
    data['text'] = this.text
    data['type'] = this.type
    data['url'] = this.url
    data['documentUrl'] = this.documentUrl
    data['order'] = this.order
    data['meetingStartDate'] = this.meetingStartDate
      ? this.meetingStartDate.toISOString()
      : <any>undefined
    data['moduleId'] = this.moduleId
    data['moduleName'] = this.moduleName
    data['instructorId'] = this.instructorId
    data['instructorName'] = this.instructorName
    data['profilePictureUrl'] = this.profilePictureUrl
    data['liked'] = this.liked
    data['likes'] = this.likes
    return data
  }
}

export interface IListNewsFeedsViewModel {
  id?: string | undefined
  name?: string | undefined
  duration?: number
  text?: string | undefined
  type?: number
  url?: string | undefined
  documentUrl?: string | undefined
  order?: number
  meetingStartDate?: Date | undefined
  moduleId?: string
  moduleName?: string | undefined
  instructorId?: string
  instructorName?: string | undefined
  profilePictureUrl?: string | undefined
  liked?: boolean
  likes?: number | undefined
}
export class ListUserNewsFeedsViewModel implements IListUserNewsFeedsViewModel {
  id?: string | undefined
  name?: string | undefined
  duration?: number
  text?: string | undefined
  type?: number
  url?: string | undefined
  documentUrl?: string | undefined
  order?: number
  notifyUsers?: boolean
  status?: number
  meetingStartDate?: Date | undefined
  expiryDate?: Date | undefined
  publishDate?: Date | undefined
  moduleId?: string
  moduleName?: string | undefined
  instructorId?: string
  instructorName?: string | undefined
  profilePictureUrl?: string | undefined
  liked?: boolean
  likes?: number | undefined

  constructor(data?: IListUserNewsFeedsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.duration = _data['duration']
      this.text = _data['text']
      this.type = _data['type']
      this.url = _data['url']
      this.documentUrl = _data['documentUrl']
      this.order = _data['order']
      this.notifyUsers = _data['notifyUsers']
      this.status = _data['status']
      this.meetingStartDate = _data['meetingStartDate']
        ? new Date(_data['meetingStartDate'].toString())
        : <any>undefined
      this.expiryDate = _data['expiryDate']
        ? new Date(_data['expiryDate'].toString())
        : <any>undefined
      this.publishDate = _data['publishDate']
        ? new Date(_data['publishDate'].toString())
        : <any>undefined
      this.moduleId = _data['moduleId']
      this.moduleName = _data['moduleName']
      this.instructorId = _data['instructorId']
      this.instructorName = _data['instructorName']
      this.profilePictureUrl = _data['profilePictureUrl']
      this.liked = _data['liked']
      this.likes = _data['likes']
    }
  }

  static fromJS(data: any): ListUserNewsFeedsViewModel {
    data = typeof data === 'object' ? data : {}

    let result = new ListUserNewsFeedsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['duration'] = this.duration
    data['text'] = this.text
    data['type'] = this.type
    data['url'] = this.url
    data['documentUrl'] = this.documentUrl
    data['order'] = this.order
    data['notifyUsers'] = this.notifyUsers
    data['status'] = this.status
    data['meetingStartDate'] = this.meetingStartDate
      ? this.meetingStartDate.toISOString()
      : <any>undefined
    data['expiryDate'] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined
    data['publishDate'] = this.publishDate ? this.publishDate.toISOString() : <any>undefined
    data['moduleId'] = this.moduleId
    data['moduleName'] = this.moduleName
    data['instructorId'] = this.instructorId
    data['instructorName'] = this.instructorName
    data['profilePictureUrl'] = this.profilePictureUrl
    data['liked'] = this.liked
    data['likes'] = this.likes
    return data
  }
}

export interface IListUserNewsFeedsViewModel {
  id?: string | undefined
  name?: string | undefined
  duration?: number
  text?: string | undefined
  type?: number
  url?: string | undefined
  documentUrl?: string | undefined
  order?: number
  notifyUsers?: boolean
  status?: number
  meetingStartDate?: Date | undefined
  expiryDate?: Date | undefined
  publishDate?: Date | undefined
  moduleId?: string
  moduleName?: string | undefined
  instructorId?: string
  instructorName?: string | undefined
  profilePictureUrl?: string | undefined
  liked?: boolean
  likes?: number | undefined
}

export class ListModulesByProgramIdViewModel implements IListModulesByProgramIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  order?: number
  cohortName?: string;
  completed?: number | undefined

  constructor(data?: IListModulesByProgramIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.duration = _data['duration']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined
      this.order = _data['order']
      this.completed = _data['completed']
      this.cohortName = _data['cohortName']
    }
  }

  static fromJS(data: any): ListModulesByProgramIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListModulesByProgramIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['duration'] = this.duration
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['order'] = this.order
    data['completed'] = this.completed
    data['cohortName'] = this.cohortName
    return data
  }
}

export interface IListModulesByProgramIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  order?: number
  cohortName?: string;
  completed?: number | undefined
}

export class ListModulesByEliteClubIdViewModel implements IListModulesByEliteClubIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  instructorId?: string | undefined
  order?: number
  completed?: number | undefined

  constructor(data?: IListModulesByEliteClubIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.duration = _data['duration']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined
      this.instructorId = _data['instructorId']
      this.order = _data['order']
      this.completed = _data['completed']
    }
  }

  static fromJS(data: any): ListModulesByEliteClubIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListModulesByEliteClubIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['duration'] = this.duration
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['instructorId'] = this.instructorId
    data['order'] = this.order
    data['completed'] = this.completed
    return data
  }
}

export interface IListModulesByEliteClubIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  instructorId?: string | undefined
  order?: number
  completed?: number | undefined
}

export class DeactivateTeamMemberCommand implements IDeactivateTeamMemberCommand {
  id?: string

  constructor(data?: IDeactivateTeamMemberCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
    }
  }

  static fromJS(data: any): DeactivateTeamMemberCommand {
    data = typeof data === 'object' ? data : {}
    let result = new DeactivateTeamMemberCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    return data
  }
}

export interface IDeactivateTeamMemberCommand {
  id?: string
}

export class GetModuleByIdViewModel implements IGetModuleByIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  instructorId?: string
  programId?: string
  location?: string | undefined
  moduleUrl?: string | undefined
  overview?: string | undefined
  order?: number

  constructor(data?: IGetModuleByIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.duration = _data['duration']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined
      this.instructorId = _data['instructorId']
      this.programId = _data['programId']
      this.location = _data['location']
      this.moduleUrl = _data['moduleUrl']
      this.overview = _data['overview']
      this.order = _data['order']
    }
  }

  static fromJS(data: any): GetModuleByIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetModuleByIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['duration'] = this.duration
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['instructorId'] = this.instructorId
    data['programId'] = this.programId
    data['location'] = this.location
    data['moduleUrl'] = this.moduleUrl
    data['overview'] = this.overview
    data['order'] = this.order
    return data
  }
}

export interface IGetModuleByIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  instructorId?: string
  programId?: string
  location?: string | undefined
  moduleUrl?: string | undefined
  overview?: string | undefined
  order?: number
}

export class ListUserProfessionalExperiencesViewModel
  implements IListUserProfessionalExperiencesViewModel {
  id?: string
  completed?: boolean
  positionLevel?: number
  organizationLevel?: number
  jobTitle?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName?: string | undefined
  organizationName_AR?: string | undefined
  from?: Date
  to?: Date | undefined
  industry?: string
  sector?: string
  otherIndustry?: string | undefined
  otherSector?: string | undefined
  organizationSize?: number | undefined

  constructor(data?: IListUserProfessionalExperiencesViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.jobTitle = _data['jobTitle']
      this.jobTitle_AR = _data['jobTitle_AR']
      this.organizationName = _data['organizationName']
      this.organizationName_AR = _data['organizationName_AR']
      this.from = _data['from'] ? new Date(_data['from'].toString()) : <any>undefined
      this.to = _data['to'] ? new Date(_data['to'].toString()) : <any>undefined
      this.industry = _data['industry']
      this.sector = _data['sector']
      this.otherIndustry = _data['otherIndustry']
      this.otherSector = _data['otherSector']
      this.organizationSize = _data['organizationSize']
      this.positionLevel = _data['positionLevel']
      this.organizationLevel = _data['organizationLevel']
      this.completed = _data['completed']
    }
  }

  static fromJS(data: any): ListUserProfessionalExperiencesViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserProfessionalExperiencesViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['jobTitle'] = this.jobTitle
    data['jobTitle_AR'] = this.jobTitle_AR
    data['organizationName'] = this.organizationName
    data['organizationName_AR'] = this.organizationName_AR
    data['from'] = this.from ? this.from.toISOString() : <any>undefined
    data['to'] = this.to ? this.to.toISOString() : <any>undefined
    data['industry'] = this.industry
    data['positionLevel'] = this.positionLevel
    data['organizationLevel'] = this.organizationLevel
    data['sector'] = this.sector
    data['otherIndustry'] = this.otherIndustry
    data['otherSector'] = this.otherSector
    data['organizationSize'] = this.organizationSize
    data['completed'] = this.completed
    return data
  }
}

export interface IListUserProfessionalExperiencesViewModel {
  id?: string
  positionLevel?: number
  organizationLevel?: number
  jobTitle?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName?: string | undefined
  organizationName_AR?: string | undefined
  from?: Date
  to?: Date | undefined
  industry?: string
  sector?: string
  otherIndustry?: string | undefined
  otherSector?: string | undefined
  organizationSize?: number | undefined
}

export class AddProfessionalExperienceCommand implements IAddProfessionalExperienceCommand {
  contactId?: string
  jobTitle?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName?: string | undefined
  organizationName_AR?: string | undefined
  from?: Date
  to?: Date | undefined
  industry?: string
  positionLevel?: number
  organizationLevel?: number
  sector?: string
  otherIndustry?: string | undefined
  otherSector?: string | undefined
  organizationSize?: number | undefined

  constructor(data?: IAddProfessionalExperienceCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.contactId = _data['contactId']
      this.jobTitle = _data['jobTitle']
      this.jobTitle_AR = _data['jobTitle_AR']
      this.organizationName = _data['organizationName']
      this.organizationName_AR = _data['organizationName_AR']
      this.from = _data['from'] ? new Date(_data['from'].toString()) : <any>undefined
      this.to = _data['to'] ? new Date(_data['to'].toString()) : <any>undefined
      this.industry = _data['industry']
      this.sector = _data['sector']
      this.otherIndustry = _data['otherIndustry']
      this.otherSector = _data['otherSector']
      this.organizationSize = _data['organizationSize']
      this.positionLevel = _data['positionLevel']
      this.organizationLevel = _data['organizationLevel']
    }
  }

  static fromJS(data: any): AddProfessionalExperienceCommand {
    data = typeof data === 'object' ? data : {}
    let result = new AddProfessionalExperienceCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['contactId'] = this.contactId
    data['jobTitle'] = this.jobTitle
    data['jobTitle_AR'] = this.jobTitle_AR
    data['organizationName'] = this.organizationName
    data['organizationName_AR'] = this.organizationName_AR
    data['from'] = this.from ? this.from.toISOString() : <any>undefined
    data['to'] = this.to ? this.to.toISOString() : <any>undefined
    data['industry'] = this.industry
    data['sector'] = this.sector
    data['otherIndustry'] = this.otherIndustry
    data['otherSector'] = this.otherSector
    data['organizationSize'] = this.organizationSize
    data['positionLevel'] = this.positionLevel
    data['organizationLevel'] = this.organizationLevel
    return data
  }
}

export interface IAddProfessionalExperienceCommand {
  contactId?: string
  positionLevel?: number
  organizationLevel?: number
  jobTitle?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName?: string | undefined
  organizationName_AR?: string | undefined
  from?: Date
  to?: Date | undefined
  industry?: string
  sector?: string
  otherIndustry?: string | undefined
  otherSector?: string | undefined
  organizationSize?: number | undefined
}

export class EditProfessionalExperienceCommand implements IEditProfessionalExperienceCommand {
  id?: string
  positionLevel?: number
  organizationLevel?: number
  jobTitle?: string | undefined
  organizationName?: string | undefined
  from?: Date
  to?: Date | undefined
  industry?: string
  sector?: string
  otherIndustry?: string | undefined
  otherSector?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName_AR?: string | undefined
  organizationSize?: number | undefined

  constructor(data?: IEditProfessionalExperienceCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.jobTitle = _data['jobTitle']
      this.organizationName = _data['organizationName']
      this.from = _data['from'] ? new Date(_data['from'].toString()) : <any>undefined
      this.to = _data['to'] ? new Date(_data['to'].toString()) : <any>undefined
      this.industry = _data['industry']
      this.sector = _data['sector']
      this.otherIndustry = _data['otherIndustry']
      this.otherSector = _data['otherSector']
      this.jobTitle_AR = _data['jobTitle_AR']
      this.organizationName_AR = _data['organizationName_AR']
      this.organizationSize = _data['organizationSize']
      this.positionLevel = _data['positionLevel']
      this.organizationLevel = _data['organizationLevel']
    }
  }

  static fromJS(data: any): EditProfessionalExperienceCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditProfessionalExperienceCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['jobTitle'] = this.jobTitle
    data['organizationName'] = this.organizationName
    data['from'] = this.from ? this.from.toISOString() : <any>undefined
    data['to'] = this.to ? this.to.toISOString() : <any>undefined
    data['industry'] = this.industry
    data['sector'] = this.sector
    data['otherIndustry'] = this.otherIndustry
    data['otherSector'] = this.otherSector
    data['jobTitle_AR'] = this.jobTitle_AR
    data['organizationName_AR'] = this.organizationName_AR
    data['organizationSize'] = this.organizationSize
    data['positionLevel'] = this.positionLevel
    data['organizationLevel'] = this.organizationLevel
    return data
  }
}

export interface IEditProfessionalExperienceCommand {
  id?: string
  positionLevel?: number
  organizationLevel?: number
  jobTitle?: string | undefined
  organizationName?: string | undefined
  from?: Date
  to?: Date | undefined
  industry?: string
  sector?: string
  otherIndustry?: string | undefined
  otherSector?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName_AR?: string | undefined
  organizationSize?: number | undefined
}

export class GetUserProfileViewModel implements IGetUserProfileViewModel {
  id?: string
  firstName?: string | undefined
  firstName_AR?: string | undefined
  middleName?: string | undefined
  middleName_AR?: string | undefined
  lastName?: string | undefined
  lastName_AR?: string | undefined
  gender?: number | undefined
  nationality?: string | undefined
  birthdate?: Date | undefined
  email?: string | undefined
  businessEmail?: string | undefined
  mobilePhone?: string | undefined
  mobilePhone2?: string | undefined
  telephone?: string | undefined
  residenceCountry?: string | undefined
  city?: string | undefined
  postOfficeBox?: string | undefined
  address?: string | undefined
  linkedInUrl?: string | undefined
  instagramUrl?: string | undefined
  twitterUrl?: string | undefined
  emiratesId?: string | undefined
  passportNumber?: string | undefined
  passportExpiryDate?: Date | undefined
  profilePictureUrl?: string | undefined
  maritalStatus?: number | undefined
  salutation?: number | undefined
  emiratesIdExpiryDate?: Date | undefined
  passportIssuingAuthority?: number | undefined
  isActiveMember?: boolean | undefined
  role?: number
  aboutInstructor?: string | undefined
  representedUniversityIntroduction?: string | undefined

  constructor(data?: IGetUserProfileViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.firstName = _data['firstName']
      this.firstName_AR = _data['firstName_AR']
      this.middleName = _data['middleName']
      this.middleName_AR = _data['middleName_AR']
      this.lastName = _data['lastName']
      this.lastName_AR = _data['lastName_AR']
      this.gender = _data['gender']
      this.nationality = _data['nationality']
      this.birthdate = _data['birthdate'] ? new Date(_data['birthdate'].toString()) : <any>undefined
      this.email = _data['email']
      this.businessEmail = _data['businessEmail']
      this.mobilePhone = _data['mobilePhone']
      this.mobilePhone2 = _data['mobilePhone2']
      this.telephone = _data['telephone']
      this.residenceCountry = _data['residenceCountry']
      this.city = _data['city']
      this.postOfficeBox = _data['postOfficeBox']
      this.address = _data['address']
      this.linkedInUrl = _data['linkedInUrl']
      this.instagramUrl = _data['instagramUrl']
      this.twitterUrl = _data['twitterUrl']
      this.emiratesId = _data['emiratesId']
      this.passportNumber = _data['passportNumber']
      this.passportExpiryDate = _data['passportExpiryDate']
        ? new Date(_data['passportExpiryDate'].toString())
        : <any>undefined
      this.profilePictureUrl = _data['profilePictureUrl']
      this.maritalStatus = _data['maritalStatus']
      this.salutation = _data['salutation']
      this.emiratesIdExpiryDate = _data['emiratesIdExpiryDate']
        ? new Date(_data['emiratesIdExpiryDate'].toString())
        : <any>undefined
      this.passportIssuingAuthority = _data['passportIssuingAuthority']
      this.isActiveMember = _data['isActiveMember']
      this.role = _data['role']
      this.aboutInstructor = _data['aboutInstructor']
      this.representedUniversityIntroduction = _data['representedUniversityIntroduction']
    }
  }

  static fromJS(data: any): GetUserProfileViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetUserProfileViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['firstName'] = this.firstName
    data['firstName_AR'] = this.firstName_AR
    data['middleName'] = this.middleName
    data['middleName_AR'] = this.middleName_AR
    data['lastName'] = this.lastName
    data['lastName_AR'] = this.lastName_AR
    data['gender'] = this.gender
    data['nationality'] = this.nationality
    data['birthdate'] = this.birthdate ? this.birthdate.toISOString() : <any>undefined
    data['email'] = this.email
    data['businessEmail'] = this.businessEmail
    data['mobilePhone'] = this.mobilePhone
    data['mobilePhone2'] = this.mobilePhone2
    data['telephone'] = this.telephone
    data['residenceCountry'] = this.residenceCountry
    data['city'] = this.city
    data['postOfficeBox'] = this.postOfficeBox
    data['address'] = this.address
    data['linkedInUrl'] = this.linkedInUrl
    data['instagramUrl'] = this.instagramUrl
    data['twitterUrl'] = this.twitterUrl
    data['emiratesId'] = this.emiratesId
    data['passportNumber'] = this.passportNumber
    data['passportExpiryDate'] = this.passportExpiryDate
      ? this.passportExpiryDate.toISOString()
      : <any>undefined
    data['profilePictureUrl'] = this.profilePictureUrl
    data['maritalStatus'] = this.maritalStatus
    data['salutation'] = this.salutation
    data['emiratesIdExpiryDate'] = this.emiratesIdExpiryDate
      ? this.emiratesIdExpiryDate.toISOString()
      : <any>undefined
    data['passportIssuingAuthority'] = this.passportIssuingAuthority
    data['isActiveMember'] = this.isActiveMember
    data['role'] = this.role
    data['aboutInstructor'] = this.aboutInstructor
    data['representedUniversityIntroduction'] = this.representedUniversityIntroduction
    return data
  }
}

export interface IGetUserProfileViewModel {
  id?: string
  firstName?: string | undefined
  firstName_AR?: string | undefined
  middleName?: string | undefined
  middleName_AR?: string | undefined
  lastName?: string | undefined
  lastName_AR?: string | undefined
  gender?: number | undefined
  nationality?: string | undefined
  birthdate?: Date | undefined
  email?: string | undefined
  businessEmail?: string | undefined
  mobilePhone?: string | undefined
  mobilePhone2?: string | undefined
  telephone?: string | undefined
  residenceCountry?: string | undefined
  city?: string | undefined
  postOfficeBox?: string | undefined
  address?: string | undefined
  linkedInUrl?: string | undefined
  instagramUrl?: string | undefined
  twitterUrl?: string | undefined
  emiratesId?: string | undefined
  passportNumber?: string | undefined
  passportExpiryDate?: Date | undefined
  profilePictureUrl?: string | undefined
  maritalStatus?: number | undefined
  salutation?: number | undefined
  emiratesIdExpiryDate?: Date | undefined
  passportIssuingAuthority?: number | undefined
  isActiveMember?: boolean | undefined
  role?: number
  aboutInstructor?: string | undefined
  representedUniversityIntroduction?: string | undefined
}

export class SetIsActiveMemberCommand implements ISetIsActiveMemberCommand {
  userId?: string
  isActiveMember?: boolean | undefined

  constructor(data?: ISetIsActiveMemberCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId']
      this.isActiveMember = _data['isActiveMember']
    }
  }

  static fromJS(data: any): SetIsActiveMemberCommand {
    data = typeof data === 'object' ? data : {}
    let result = new SetIsActiveMemberCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['userId'] = this.userId
    data['isActiveMember'] = this.isActiveMember
    return data
  }
}

export interface ISetIsActiveMemberCommand {
  userId?: string
  isActiveMember?: boolean | undefined
}

export class StringBooleanKeyValuePair implements IStringBooleanKeyValuePair {
  readonly key?: string | undefined
  readonly value?: boolean

  constructor(data?: IStringBooleanKeyValuePair) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      ; (<any>this).key = _data['key']
        ; (<any>this).value = _data['value']
    }
  }

  static fromJS(data: any): StringBooleanKeyValuePair {
    data = typeof data === 'object' ? data : {}
    let result = new StringBooleanKeyValuePair()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['key'] = this.key
    data['value'] = this.value
    return data
  }
}

export interface IStringBooleanKeyValuePair {
  key?: string | undefined
  value?: boolean
}

export class GetUserProfileCompletionViewModel implements IGetUserProfileCompletionViewModel {
  completionPercentage?: number
  sections?: StringBooleanKeyValuePair[] | undefined
  requiresUpdate?: boolean

  constructor(data?: IGetUserProfileCompletionViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.completionPercentage = _data['completionPercentage']
      this.requiresUpdate = _data['requiresUpdate']
      if (Array.isArray(_data['sections'])) {
        this.sections = [] as any
        for (let item of _data['sections'])
          this.sections!.push(StringBooleanKeyValuePair.fromJS(item))
      }
    }
  }

  static fromJS(data: any): GetUserProfileCompletionViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetUserProfileCompletionViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['completionPercentage'] = this.completionPercentage
    data['requiresUpdate'] = this.requiresUpdate
    if (Array.isArray(this.sections)) {
      data['sections'] = []
      for (let item of this.sections) data['sections'].push(item.toJSON())
    }
    return data
  }
}

export interface IGetUserProfileCompletionViewModel {
  completionPercentage?: number
  sections?: StringBooleanKeyValuePair[] | undefined
  requiresUpdate?: boolean
}

export class EditUserGeneralInformationCommand implements IEditUserGeneralInformationCommand {
  id?: string
  firstName?: string | undefined
  firstName_AR?: string | undefined
  middleName?: string | undefined
  middleName_AR?: string | undefined
  lastName?: string | undefined
  lastName_AR?: string | undefined
  gender?: number | undefined
  nationality?: string | undefined
  birthdate?: Date | undefined
  maritalStatus?: number | undefined
  telephone?: string | undefined
  salutation?: number | undefined

  constructor(data?: IEditUserGeneralInformationCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.firstName = _data['firstName']
      this.firstName_AR = _data['firstName_AR']
      this.middleName = _data['middleName']
      this.middleName_AR = _data['middleName_AR']
      this.lastName = _data['lastName']
      this.lastName_AR = _data['lastName_AR']
      this.gender = _data['gender']
      this.nationality = _data['nationality']
      this.birthdate = _data['birthdate'] ? new Date(_data['birthdate'].toString()) : <any>undefined
      this.maritalStatus = _data['maritalStatus']
      this.telephone = _data['telephone']
      this.salutation = _data['salutation']
    }
  }

  static fromJS(data: any): EditUserGeneralInformationCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditUserGeneralInformationCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['firstName'] = this.firstName
    data['firstName_AR'] = this.firstName_AR
    data['middleName'] = this.middleName
    data['middleName_AR'] = this.middleName_AR
    data['lastName'] = this.lastName
    data['lastName_AR'] = this.lastName_AR
    data['gender'] = this.gender
    data['nationality'] = this.nationality
    data['birthdate'] = this.birthdate ? this.birthdate.toISOString() : <any>undefined
    data['maritalStatus'] = this.maritalStatus
    data['telephone'] = this.telephone
    data['salutation'] = this.salutation
    return data
  }
}

export interface IEditUserGeneralInformationCommand {
  id?: string
  firstName?: string | undefined
  firstName_AR?: string | undefined
  middleName?: string | undefined
  middleName_AR?: string | undefined
  lastName?: string | undefined
  lastName_AR?: string | undefined
  gender?: number | undefined
  nationality?: string | undefined
  birthdate?: Date | undefined
  maritalStatus?: number | undefined
  telephone?: string | undefined
  salutation?: number | undefined
}

export class EditUserContactDetailsCommand implements IEditUserContactDetailsCommand {
  id?: string
  email?: string | undefined
  businessEmail?: string | undefined
  mobilePhone?: string | undefined
  mobilePhone2?: string | undefined
  telephone?: string | undefined
  residenceCountry?: string | undefined
  city?: string | undefined
  postOfficeBox?: string | undefined
  address?: string | undefined
  linkedInUrl?: string | undefined
  instagramUrl?: string | undefined
  twitterUrl?: string | undefined

  constructor(data?: IEditUserContactDetailsCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.email = _data['email']
      this.businessEmail = _data['businessEmail']
      this.mobilePhone = _data['mobilePhone']
      this.mobilePhone2 = _data['mobilePhone2']
      this.telephone = _data['telephone']
      this.residenceCountry = _data['residenceCountry']
      this.city = _data['city']
      this.postOfficeBox = _data['postOfficeBox']
      this.address = _data['address']
      this.linkedInUrl = _data['linkedInUrl']
      this.instagramUrl = _data['instagramUrl']
      this.twitterUrl = _data['twitterUrl']
    }
  }

  static fromJS(data: any): EditUserContactDetailsCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditUserContactDetailsCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['email'] = this.email
    data['businessEmail'] = this.businessEmail
    data['mobilePhone'] = this.mobilePhone
    data['mobilePhone2'] = this.mobilePhone2
    data['telephone'] = this.telephone
    data['residenceCountry'] = this.residenceCountry
    data['city'] = this.city
    data['postOfficeBox'] = this.postOfficeBox
    data['address'] = this.address
    data['linkedInUrl'] = this.linkedInUrl
    data['instagramUrl'] = this.instagramUrl
    data['twitterUrl'] = this.twitterUrl
    return data
  }
}

export interface IEditUserContactDetailsCommand {
  id?: string
  email?: string | undefined
  businessEmail?: string | undefined
  mobilePhone?: string | undefined
  mobilePhone2?: string | undefined
  telephone?: string | undefined
  residenceCountry?: string | undefined
  city?: string | undefined
  postOfficeBox?: string | undefined
  address?: string | undefined
  linkedInUrl?: string | undefined
  instagramUrl?: string | undefined
  twitterUrl?: string | undefined
}

export class EditUserIdentityDetailsCommand implements IEditUserIdentityDetailsCommand {
  id?: string
  emiratesId?: string | undefined
  passportNumber?: string | undefined
  passportExpiryDate?: Date | undefined
  emiratesIdExpiryDate?: Date | undefined
  passportIssuingAuthority?: number | undefined

  constructor(data?: IEditUserIdentityDetailsCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.emiratesId = _data['emiratesId']
      this.passportNumber = _data['passportNumber']
      this.passportExpiryDate = _data['passportExpiryDate']
        ? new Date(_data['passportExpiryDate'].toString())
        : <any>undefined
      this.emiratesIdExpiryDate = _data['emiratesIdExpiryDate']
        ? new Date(_data['emiratesIdExpiryDate'].toString())
        : <any>undefined
      this.passportIssuingAuthority = _data['passportIssuingAuthority']
    }
  }

  static fromJS(data: any): EditUserIdentityDetailsCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditUserIdentityDetailsCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['emiratesId'] = this.emiratesId
    data['passportNumber'] = this.passportNumber
    data['passportExpiryDate'] = this.passportExpiryDate
      ? this.passportExpiryDate.toISOString()
      : <any>undefined
    data['emiratesIdExpiryDate'] = this.emiratesIdExpiryDate
      ? this.emiratesIdExpiryDate.toISOString()
      : <any>undefined
    data['passportIssuingAuthority'] = this.passportIssuingAuthority
    return data
  }
}

export interface IEditUserIdentityDetailsCommand {
  id?: string
  emiratesId?: string | undefined
  passportNumber?: string | undefined
  passportExpiryDate?: Date | undefined
  emiratesIdExpiryDate?: Date | undefined
  passportIssuingAuthority?: number | undefined
}

export class ListAlumniUsersForChatViewModel implements IListAlumniUsersForChatViewModel {
  id?: string | undefined
  fullName?: string | undefined
  profilePictureUrl?: string | undefined

  constructor(data?: IListAlumniUsersForChatViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.fullName = _data['FullName']
      this.profilePictureUrl = _data['ProfilePictureUrl']
    }
  }

  static fromJS(data: any): ListAlumniUsersForChatViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListAlumniUsersForChatViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['FullName'] = this.fullName
    data['ProfilePictureUrl'] = this.profilePictureUrl
    return data
  }
}

export interface IListAlumniUsersForChatViewModel {
  id?: string | undefined
  fullName?: string | undefined
  profilePictureUrl?: string | undefined
}

export class GetUserLearningPreferencesViewModel implements IGetUserLearningPreferencesViewModel {
  readonly selectedValues?: number[] | undefined

  constructor(data?: IGetUserLearningPreferencesViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['selectedValues'])) {
        ; (<any>this).selectedValues = [] as any
        for (let item of _data['selectedValues']) (<any>this).selectedValues!.push(item)
      }
    }
  }

  static fromJS(data: any): GetUserLearningPreferencesViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetUserLearningPreferencesViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    if (Array.isArray(this.selectedValues)) {
      data['selectedValues'] = []
      for (let item of this.selectedValues) data['selectedValues'].push(item)
    }
    return data
  }
}

export interface IGetUserLearningPreferencesViewModel {
  selectedValues?: number[] | undefined
}

export class EditUserLearningPreferencesCommand implements IEditUserLearningPreferencesCommand {
  userId?: string
  selectedValues?: number[] | undefined

  constructor(data?: IEditUserLearningPreferencesCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId']
      if (Array.isArray(_data['selectedValues'])) {
        this.selectedValues = [] as any
        for (let item of _data['selectedValues']) this.selectedValues!.push(item)
      }
    }
  }

  static fromJS(data: any): EditUserLearningPreferencesCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditUserLearningPreferencesCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['userId'] = this.userId
    if (Array.isArray(this.selectedValues)) {
      data['selectedValues'] = []
      for (let item of this.selectedValues) data['selectedValues'].push(item)
    }
    return data
  }
}

export interface IEditUserLearningPreferencesCommand {
  userId?: string
  selectedValues?: number[] | undefined
}

export class GetUserDisclaimerViewModel implements IGetUserDisclaimerViewModel {
  id?: string
  disclaimer?: boolean

  constructor(data?: IGetUserDisclaimerViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.disclaimer = _data['disclaimer']
    }
  }

  static fromJS(data: any): GetUserDisclaimerViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetUserDisclaimerViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['disclaimer'] = this.disclaimer
    return data
  }
}

export interface IGetUserDisclaimerViewModel {
  id?: string
  disclaimer?: boolean
}

export class ListProgramQuestionByProgramIdViewModel
  implements IListProgramQuestionByProgramIdViewModel {
  id?: string
  question?: string | undefined

  constructor(data?: IListProgramQuestionByProgramIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.question = _data['question']
    }
  }

  static fromJS(data: any): ListProgramQuestionByProgramIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListProgramQuestionByProgramIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['question'] = this.question
    return data
  }
}

export interface IListProgramQuestionByProgramIdViewModel {
  id?: string
  question?: string | undefined
}

export class DashboardProgram implements IDashboardProgram {
  id?: string
  name?: string | undefined
  description?: string | undefined
  value?: number
  url?: string | undefined

  constructor(data?: IDashboardProgram) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.description = _data['description']
      this.value = _data['value']
      this.url = _data['url']
    }
  }

  static fromJS(data: any): DashboardProgram {
    data = typeof data === 'object' ? data : {}
    let result = new DashboardProgram()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['description'] = this.description
    data['value'] = this.value
    data['url'] = this.url
    return data
  }
}

export interface IDashboardProgram {
  id?: string
  name?: string | undefined
  description?: string | undefined
  value?: number
  url?: string | undefined
}

export class DashboardModule implements IDashboardModule {
  id?: string
  programId?: string
  name?: string | undefined
  description?: string | undefined
  value?: number

  constructor(data?: IDashboardModule) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.programId = _data['programId']
      this.name = _data['name']
      this.description = _data['description']
      this.value = _data['value']
    }
  }

  static fromJS(data: any): DashboardModule {
    data = typeof data === 'object' ? data : {}
    let result = new DashboardModule()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['programId'] = this.programId
    data['name'] = this.name
    data['description'] = this.description
    data['value'] = this.value
    return data
  }
}

export interface IDashboardModule {
  id?: string
  programId?: string
  name?: string | undefined
  description?: string | undefined
  value?: number
}

export class DashboardViewModel implements IDashboardViewModel {
  name?: string | undefined
  name_AR?: string | undefined
  value?: number
  details?: KPI[] | undefined

  constructor(data?: IDashboardViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.value = _data['value']
      if (Array.isArray(_data['details'])) {
        this.details = [] as any
        for (let item of _data['details']) this.details!.push(KPI.fromJS(item))
      }
    }
  }

  static fromJS(data: any): DashboardViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new DashboardViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['value'] = this.value
    if (Array.isArray(this.details)) {
      data['details'] = []
      for (let item of this.details) data['details'].push(item.toJSON())
    }
    return data
  }
}

export interface IDashboardViewModel {
  name?: string | undefined
  name_AR?: string | undefined
  value?: number
  details?: KPI[] | undefined
}

export class KPI implements IKPI {
  name?: string | undefined
  name_AR?: string | undefined
  value?: number
  order?: number

  constructor(data?: IKPI) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['Name']
      this.name_AR = _data['Name_AR']
      this.value = _data['Value']
      this.order = _data['Order']
    }
  }

  static fromJS(data: any): KPI {
    data = typeof data === 'object' ? data : {}
    let result = new KPI()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Name'] = this.name
    data['Name_AR'] = this.name_AR
    data['Value'] = this.value
    data['Order'] = this.order
    return data
  }
}

export interface IKPI {
  name?: string | undefined
  name_AR?: string | undefined
  value?: number
  order?: number
}

export class Programs implements IPrograms {
  id?: string
  name?: string | undefined
  description?: string | undefined
  value?: number
  url?: string | undefined

  constructor(data?: IPrograms) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.description = _data['description']
      this.value = _data['value']
      this.url = _data['url']
    }
  }

  static fromJS(data: any): Programs {
    data = typeof data === 'object' ? data : {}
    let result = new Programs()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['description'] = this.description
    data['value'] = this.value
    data['url'] = this.url
    return data
  }
}

export interface IPrograms {
  id?: string
  name?: string | undefined
  description?: string | undefined
  value?: number
  url?: string | undefined
}

export class Modules implements IModules {
  id?: string
  programId?: string
  name?: string | undefined
  description?: string | undefined
  value?: number

  constructor(data?: IModules) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.programId = _data['programId']
      this.name = _data['name']
      this.description = _data['description']
      this.value = _data['value']
    }
  }

  static fromJS(data: any): Modules {
    data = typeof data === 'object' ? data : {}
    let result = new Modules()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['programId'] = this.programId
    data['name'] = this.name
    data['description'] = this.description
    data['value'] = this.value
    return data
  }
}

export interface IModules {
  id?: string
  programId?: string
  name?: string | undefined
  description?: string | undefined
  value?: number
}

export class ListProgramByUserModuleViewModel implements IListProgramByUserModuleViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  pictureUrl?: string | undefined

  constructor(data?: IListProgramByUserModuleViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.duration = _data['duration']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined
      this.pictureUrl = _data['pictureUrl']
    }
  }

  static fromJS(data: any): ListProgramByUserModuleViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListProgramByUserModuleViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['duration'] = this.duration
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['pictureUrl'] = this.pictureUrl
    return data
  }
}

export interface IListProgramByUserModuleViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  pictureUrl?: string | undefined
}

export class GetProgramByIdViewModel implements IGetProgramByIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  longDescription?: string | undefined
  longDescription_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  pictureUrl?: string | undefined

  constructor(data?: IGetProgramByIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.longDescription = _data['longDescription']
      this.longDescription_AR = _data['longDescription_AR']
      this.duration = _data['duration']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined
      this.pictureUrl = _data['pictureUrl']
    }
  }

  static fromJS(data: any): GetProgramByIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetProgramByIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['longDescription'] = this.longDescription
    data['longDescription_AR'] = this.longDescription_AR
    data['duration'] = this.duration
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['pictureUrl'] = this.pictureUrl
    return data
  }
}

export interface IGetProgramByIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  longDescription?: string | undefined
  longDescription_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  pictureUrl?: string | undefined
}

export class ListProgramByCohortContactViewModel implements IListProgramByCohortContactViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  pictureUrl?: string | undefined
  completed?: number

  constructor(data?: IListProgramByCohortContactViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.duration = _data['duration']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined
      this.pictureUrl = _data['pictureUrl']
      this.completed = _data['completed']
    }
  }

  static fromJS(data: any): ListProgramByCohortContactViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListProgramByCohortContactViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['duration'] = this.duration
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['pictureUrl'] = this.pictureUrl
    data['completed'] = this.completed
    return data
  }
}

export interface IListProgramByCohortContactViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  pictureUrl?: string | undefined
  completed?: number
}

export class ListApplicantProjectsViewModel implements IListApplicantProjectsViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  presentationDate?: Date | undefined
  projectStatus?: number
  type?: number
  moduleId?: string
  moduleName?: string | undefined
  attachmentUrl?: string | undefined
  topicId?: string
  topicName?: string | undefined
  programId?: string

  constructor(data?: IListApplicantProjectsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.topic = _data['Topic']
      this.topic_Ar = _data['Topic_Ar']
      this.description = _data['Description']
      this.description_Ar = _data['Description_Ar']
      this.startDate = _data['StartDate'] ? new Date(_data['StartDate'].toString()) : <any>undefined
      this.endDate = _data['EndDate'] ? new Date(_data['EndDate'].toString()) : <any>undefined
      this.presentationDate = _data['PresentationDate']
        ? new Date(_data['PresentationDate'].toString())
        : <any>undefined
      this.projectStatus = _data['ProjectStatus']
      this.type = _data['Type']
      this.moduleId = _data['ModuleId']
      this.moduleName = _data['ModuleName']
      this.attachmentUrl = _data['AttachmentUrl']
      this.topicId = _data['TopicId']
      this.topicName = _data['TopicName']
      this.programId = _data['ProgramId']
    }
  }

  static fromJS(data: any): ListApplicantProjectsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListApplicantProjectsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Topic'] = this.topic
    data['Topic_Ar'] = this.topic_Ar
    data['Description'] = this.description
    data['Description_Ar'] = this.description_Ar
    data['StartDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['EndDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['PresentationDate'] = this.presentationDate
      ? this.presentationDate.toISOString()
      : <any>undefined
    data['ProjectStatus'] = this.projectStatus
    data['Type'] = this.type
    data['ModuleId'] = this.moduleId
    data['ModuleName'] = this.moduleName
    data['AttachmentUrl'] = this.attachmentUrl
    data['TopicId'] = this.topicId
    data['TopicName'] = this.topicName
    data['ProgramId'] = this.programId
    return data
  }
}

export interface IListApplicantProjectsViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  presentationDate?: Date | undefined
  projectStatus?: number
  type?: number
  moduleId?: string
  moduleName?: string | undefined
  attachmentUrl?: string | undefined
  topicId?: string
  topicName?: string | undefined
  programId?: string
}

export class GetInstructorProjectViewModel implements IGetInstructorProjectViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  projectStatus?: number

  constructor(data?: IGetInstructorProjectViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.topic = _data['topic']
      this.topic_Ar = _data['topic_Ar']
      this.description = _data['description']
      this.description_Ar = _data['description_Ar']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined
      this.projectStatus = _data['projectStatus']
    }
  }

  static fromJS(data: any): GetInstructorProjectViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetInstructorProjectViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['topic'] = this.topic
    data['topic_Ar'] = this.topic_Ar
    data['description'] = this.description
    data['description_Ar'] = this.description_Ar
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['projectStatus'] = this.projectStatus
    return data
  }
}

export interface IGetInstructorProjectViewModel {
  id?: string | undefined
  topic?: string | undefined
  topic_Ar?: string | undefined
  description?: string | undefined
  description_Ar?: string | undefined
  startDate?: Date
  endDate?: Date
  projectStatus?: number
}

export class CreateInstructorProjectCommand implements ICreateInstructorProjectCommand {
  name?: string | undefined
  name_Ar?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  instructorId?: string | undefined
  moduleId?: string

  constructor(data?: ICreateInstructorProjectCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
      this.name_Ar = _data['name_Ar']
      this.description = _data['description']
      this.description_AR = _data['description_AR']
      this.instructorId = _data['instructorId']
      this.moduleId = _data['moduleId']
    }
  }

  static fromJS(data: any): CreateInstructorProjectCommand {
    data = typeof data === 'object' ? data : {}
    let result = new CreateInstructorProjectCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['name'] = this.name
    data['name_Ar'] = this.name_Ar
    data['description'] = this.description
    data['description_AR'] = this.description_AR
    data['instructorId'] = this.instructorId
    data['moduleId'] = this.moduleId
    return data
  }
}

export interface ICreateInstructorProjectCommand {
  name?: string | undefined
  name_Ar?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  instructorId?: string | undefined
  moduleId?: string
}

export class ListUserReferencesViewModel implements IListUserReferencesViewModel {
  id?: string
  fullName?: string | undefined
  fullName_AR?: string | undefined
  jobTitle?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName?: string | undefined
  organizationName_AR?: string | undefined
  email?: string | undefined
  mobile?: string | undefined
  isCompleted?: boolean

  constructor(data?: IListUserReferencesViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.fullName = _data['fullName']
      this.fullName_AR = _data['fullName_AR']
      this.jobTitle = _data['jobTitle']
      this.jobTitle_AR = _data['jobTitle_AR']
      this.organizationName = _data['organizationName']
      this.organizationName_AR = _data['organizationName_AR']
      this.email = _data['email']
      this.mobile = _data['mobile']
      this.isCompleted = _data['isCompleted']
    }
  }

  static fromJS(data: any): ListUserReferencesViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserReferencesViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['fullName'] = this.fullName
    data['fullName_AR'] = this.fullName_AR
    data['jobTitle'] = this.jobTitle
    data['jobTitle_AR'] = this.jobTitle_AR
    data['organizationName'] = this.organizationName
    data['organizationName_AR'] = this.organizationName_AR
    data['email'] = this.email
    data['mobile'] = this.mobile
    data['isCompleted'] = this.isCompleted
    return data
  }
}

export interface IListUserReferencesViewModel {
  id?: string
  fullName?: string | undefined
  fullName_AR?: string | undefined
  jobTitle?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName?: string | undefined
  organizationName_AR?: string | undefined
  email?: string | undefined
  mobile?: string | undefined
  isCompleted?: boolean
}

export class ListPostsViewModel implements IListPostsViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  postDate?: Date
  expiryDate?: Date | undefined
  pictureUrl?: string | undefined
  profilePictureUrl?: string | undefined
  liked?: boolean
  likes?: number | undefined
  writtenByName?: string | undefined
  writtenBy?: string
  date?: Date
  type?: number
  postType: number
  videoUrl?: string | undefined

  constructor(data?: IListPostsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.description = _data['description']
      this.postDate = _data['postDate'] ? new Date(_data['postDate'].toString()) : <any>undefined
      this.expiryDate = _data['expiryDate']
        ? new Date(_data['expiryDate'].toString())
        : <any>undefined
      this.pictureUrl = _data['pictureUrl']
      this.profilePictureUrl = _data['profilePictureUrl']
      this.liked = _data['liked']
      this.likes = _data['likes']
      this.writtenByName = _data['writtenByName']
      this.writtenBy = _data['writtenBy']
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined
      this.type = _data['type']
      this.postType = _data['postType']
      this.videoUrl = _data['videoUrl']
    }
  }

  static fromJS(data: any): ListPostsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListPostsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['description'] = this.description
    data['postDate'] = this.postDate ? this.postDate.toISOString() : <any>undefined
    data['expiryDate'] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined
    data['pictureUrl'] = this.pictureUrl
    data['profilePictureUrl'] = this.profilePictureUrl
    data['liked'] = this.liked
    data['likes'] = this.likes
    data['writtenByName'] = this.writtenByName
    data['writtenBy'] = this.writtenBy
    data['date'] = this.date ? this.date.toISOString() : <any>undefined
    data['type'] = this.type
    data['postType'] = this.postType
    data['videoUrl'] = this.videoUrl
    return data
  }
}

export interface IListPostsViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  postDate?: Date
  expiryDate?: Date | undefined
  pictureUrl?: string | undefined
  profilePictureUrl?: string | undefined
  liked?: boolean
  likes?: number | undefined
  writtenByName?: string | undefined
  writtenBy?: string
  date?: Date
  type?: number
  postType: number
  videoUrl?: string | undefined
}

export class AddReferenceCommand implements IAddReferenceCommand {
  contactId?: string
  fullName?: string | undefined
  fullName_AR?: string | undefined
  jobTitle?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName?: string | undefined
  organizationName_AR?: string | undefined
  email?: string | undefined
  mobile?: string | undefined

  constructor(data?: IAddReferenceCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.contactId = _data['contactId']
      this.fullName = _data['fullName']
      this.fullName_AR = _data['fullName_AR']
      this.jobTitle = _data['jobTitle']
      this.jobTitle_AR = _data['jobTitle_AR']
      this.organizationName = _data['organizationName']
      this.organizationName_AR = _data['organizationName_AR']
      this.email = _data['email']
      this.mobile = _data['mobile']
    }
  }

  static fromJS(data: any): AddReferenceCommand {
    data = typeof data === 'object' ? data : {}
    let result = new AddReferenceCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['contactId'] = this.contactId
    data['fullName'] = this.fullName
    data['fullName_AR'] = this.fullName_AR
    data['jobTitle'] = this.jobTitle
    data['jobTitle_AR'] = this.jobTitle_AR
    data['organizationName'] = this.organizationName
    data['organizationName_AR'] = this.organizationName_AR
    data['email'] = this.email
    data['mobile'] = this.mobile
    return data
  }
}

export interface IAddReferenceCommand {
  contactId?: string
  fullName?: string | undefined
  fullName_AR?: string | undefined
  jobTitle?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName?: string | undefined
  organizationName_AR?: string | undefined
  email?: string | undefined
  mobile?: string | undefined
}

export class EditReferenceCommand implements IEditReferenceCommand {
  id?: string
  fullName?: string | undefined
  fullName_AR?: string | undefined
  jobTitle?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName?: string | undefined
  organizationName_AR?: string | undefined
  email?: string | undefined
  mobile?: string | undefined

  constructor(data?: IEditReferenceCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.fullName = _data['fullName']
      this.fullName_AR = _data['fullName_AR']
      this.jobTitle = _data['jobTitle']
      this.jobTitle_AR = _data['jobTitle_AR']
      this.organizationName = _data['organizationName']
      this.organizationName_AR = _data['organizationName_AR']
      this.email = _data['email']
      this.mobile = _data['mobile']
    }
  }

  static fromJS(data: any): EditReferenceCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditReferenceCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['fullName'] = this.fullName
    data['fullName_AR'] = this.fullName_AR
    data['jobTitle'] = this.jobTitle
    data['jobTitle_AR'] = this.jobTitle_AR
    data['organizationName'] = this.organizationName
    data['organizationName_AR'] = this.organizationName_AR
    data['email'] = this.email
    data['mobile'] = this.mobile
    return data
  }
}

export class ListModulesByCohortIdViewModel implements IListModulesByCohortIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  instructorId?: string | undefined
  order?: number

  constructor(data?: IListModulesByCohortIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.name_AR = _data['Name_AR']
      this.description = _data['Description']
      this.description_AR = _data['Description_AR']
      this.duration = _data['Duration']
      this.startDate = _data['StartDate'] ? new Date(_data['StartDate'].toString()) : <any>undefined
      this.endDate = _data['EndDate'] ? new Date(_data['EndDate'].toString()) : <any>undefined
      this.instructorId = _data['InstructorId']
      this.order = _data['Order']
    }
  }

  static fromJS(data: any): ListModulesByCohortIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListModulesByCohortIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Name_AR'] = this.name_AR
    data['Description'] = this.description
    data['Description_AR'] = this.description_AR
    data['Duration'] = this.duration
    data['StartDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['EndDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined
    data['InstructorId'] = this.instructorId
    data['Order'] = this.order
    return data
  }
}

export interface IListModulesByCohortIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  duration?: number
  startDate?: Date
  endDate?: Date
  instructorId?: string | undefined
  order?: number
}

export class ListMaterialsByCohortModuleIdViewModel
  implements IListMaterialsByCohortModuleIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  duration?: number
  location?: string | undefined
  order?: number
  startDate?: Date | undefined

  constructor(data?: IListMaterialsByCohortModuleIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.name_AR = _data['Name_AR']
      this.duration = _data['Duration']
      this.location = _data['Location']
      this.order = _data['Order']
      this.startDate = _data['StartDate'] ? new Date(_data['StartDate'].toString()) : <any>undefined
    }
  }

  static fromJS(data: any): ListMaterialsByCohortModuleIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListMaterialsByCohortModuleIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Name_AR'] = this.name_AR
    data['Duration'] = this.duration
    data['Location'] = this.location
    data['Order'] = this.order
    data['StartDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    return data
  }
}

export interface IListMaterialsByCohortModuleIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  duration?: number
  location?: string | undefined
  order?: number
  startDate?: Date | undefined
}

export class ListActiveProgramsViewModel implements IListActiveProgramsViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  pictureUrl?: string | undefined
  openForRegistration?: boolean

  constructor(data?: IListActiveProgramsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.name_AR = _data['Name_AR']
      this.description = _data['Description']
      this.description_AR = _data['Description_AR']
      this.pictureUrl = _data['PictureUrl']
      this.openForRegistration = _data['OpenForRegistration']
    }
  }

  static fromJS(data: any): ListActiveProgramsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListActiveProgramsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Name_AR'] = this.name_AR
    data['Description'] = this.description
    data['Description_AR'] = this.description_AR
    data['PictureUrl'] = this.pictureUrl
    data['OpenForRegistration'] = this.openForRegistration
    return data
  }
}

export interface IListActiveProgramsViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  description?: string | undefined
  description_AR?: string | undefined
  pictureUrl?: string | undefined
  openForRegistration?: boolean
}

export class GetProgramDetailsByIdViewModel implements IGetProgramDetailsByIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  longDescription?: string | undefined
  longDescription_AR?: string | undefined
  pictureUrl?: string | undefined
  enrollmentId?: string | undefined
  enrollmentStatus?: string | undefined

  constructor(data?: IGetProgramDetailsByIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.name_AR = _data['Name_AR']
      this.longDescription = _data['LongDescription']
      this.longDescription_AR = _data['LongDescription_AR']
      this.pictureUrl = _data['PictureUrl']
      this.enrollmentId = _data['EnrollmentId']
      this.enrollmentStatus = _data['EnrollmentStatus']
    }
  }

  static fromJS(data: any): GetProgramDetailsByIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetProgramDetailsByIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Name_AR'] = this.name_AR
    data['LongDescription'] = this.longDescription
    data['LongDescription_AR'] = this.longDescription_AR
    data['PictureUrl'] = this.pictureUrl
    data['EnrollmentId'] = this.enrollmentId
    data['EnrollmentStatus'] = this.enrollmentStatus
    return data
  }
}

export interface IGetProgramDetailsByIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  longDescription?: string | undefined
  longDescription_AR?: string | undefined
  pictureUrl?: string | undefined
  enrollmentId?: string | undefined
  enrollmentStatus?: string | undefined
}

export class ListSectionsByCohortMaterialIdViewModel
  implements IListSectionsByCohortMaterialIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  duration?: number
  order?: number
  startDate?: Date | undefined

  constructor(data?: IListSectionsByCohortMaterialIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.name_AR = _data['Name_AR']
      this.duration = _data['Duration']
      this.order = _data['Order']
      this.startDate = _data['StartDate'] ? new Date(_data['StartDate'].toString()) : <any>undefined
    }
  }

  static fromJS(data: any): ListSectionsByCohortMaterialIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListSectionsByCohortMaterialIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Name_AR'] = this.name_AR
    data['Duration'] = this.duration
    data['Order'] = this.order
    data['StartDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    return data
  }
}

export interface IListSectionsByCohortMaterialIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  duration?: number
  order?: number
  startDate?: Date | undefined
}

export interface IEditReferenceCommand {
  id?: string
  fullName?: string | undefined
  fullName_AR?: string | undefined
  jobTitle?: string | undefined
  jobTitle_AR?: string | undefined
  organizationName?: string | undefined
  organizationName_AR?: string | undefined
  email?: string | undefined
  mobile?: string | undefined
}

export class RegisterNewUserCommand implements IRegisterNewUserCommand {
  firstName?: string | undefined
  lastName?: string | undefined
  nationality?: string | undefined
  email?: string | undefined
  mobilePhone?: string | undefined
  password?: string | undefined
  emiratesId?: string | undefined

  constructor(data?: IRegisterNewUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.firstName = _data['firstName']
      this.lastName = _data['lastName']
      this.nationality = _data['nationality']
      this.email = _data['email']
      this.mobilePhone = _data['mobilePhone']
      this.password = _data['password']
      this.emiratesId = _data['emiratesId']
    }
  }

  static fromJS(data: any): RegisterNewUserCommand {
    data = typeof data === 'object' ? data : {}
    let result = new RegisterNewUserCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['firstName'] = this.firstName
    data['lastName'] = this.lastName
    data['nationality'] = this.nationality
    data['email'] = this.email
    data['mobilePhone'] = this.mobilePhone
    data['password'] = this.password
    data['emiratesId'] = this.emiratesId
    return data
  }
}

export interface IRegisterNewUserCommand {
  firstName?: string | undefined
  lastName?: string | undefined
  nationality?: string | undefined
  email?: string | undefined
  mobilePhone?: string | undefined
  password?: string | undefined
  emiratesId?: string | undefined
}

export class ResetPasswordCommand implements IResetPasswordCommand {
  email?: string | undefined

  constructor(data?: IResetPasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email']
    }
  }

  static fromJS(data: any): ResetPasswordCommand {
    data = typeof data === 'object' ? data : {}
    let result = new ResetPasswordCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['email'] = this.email
    return data
  }
}

export interface IResetPasswordCommand {
  email?: string | undefined
}

export class ListSectionsByMaterialIdViewModel implements IListSectionsByMaterialIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  duration?: number
  status?: number | undefined
  order?: number
  startDate?: Date | undefined
  publishDate?: Date | undefined
  sectionStatus?: number

  constructor(data?: IListSectionsByMaterialIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.duration = _data['duration']
      this.status = _data['status']
      this.order = _data['order']
      this.startDate = _data['startdate'] ? new Date(_data['startdate'].toString()) : <any>undefined
      this.publishDate = _data['publishDate']
        ? new Date(_data['publishDate'].toString())
        : <any>undefined
      this.sectionStatus = _data['sectionStatus']
    }
  }

  static fromJS(data: any): ListSectionsByMaterialIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListSectionsByMaterialIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['duration'] = this.duration
    data['status'] = this.status
    data['order'] = this.order
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['publishDate'] = this.publishDate ? this.publishDate.toISOString() : <any>undefined
    data['sectionStatus'] = this.sectionStatus
    return data
  }
}

export interface IListSectionsByMaterialIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  duration?: number
  status?: number | undefined
  order?: number
  startDate?: Date | undefined
}

export class GetSectionByIdViewModel implements IGetSectionByIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  duration?: number
  order?: number
  materialId?: string
  status?: number | undefined
  startDate?: Date | undefined
  publishDate?: Date | undefined
  sectionStatus?: number

  constructor(data?: IGetSectionByIdViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.name_AR = _data['name_AR']
      this.duration = _data['duration']
      this.order = _data['order']
      this.materialId = _data['materialId']
      this.status = _data['status']
      this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined
      this.publishDate = _data['publishDate']
        ? new Date(_data['publishDate'].toString())
        : <any>undefined
      this.sectionStatus = _data['sectionStatus']
    }
  }

  static fromJS(data: any): GetSectionByIdViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new GetSectionByIdViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['name_AR'] = this.name_AR
    data['duration'] = this.duration
    data['order'] = this.order
    data['materialId'] = this.materialId
    data['status'] = this.status
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined
    data['publishDate'] = this.publishDate ? this.publishDate.toISOString() : <any>undefined
    data['sectionStatus'] = this.sectionStatus
    return data
  }
}

export interface IGetSectionByIdViewModel {
  id?: string
  name?: string | undefined
  name_AR?: string | undefined
  duration?: number
  order?: number
  materialId?: string
  status?: number | undefined
  startDate?: Date | undefined
  publishDate?: Date | undefined
  sectionStatus?: number
}

export class ListUserSkillsAndInterestsViewModel implements IListUserSkillsAndInterestsViewModel {
  id?: string
  name?: string | undefined

  constructor(data?: IListUserSkillsAndInterestsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
    }
  }

  static fromJS(data: any): ListUserSkillsAndInterestsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserSkillsAndInterestsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    return data
  }
}

export interface IListUserSkillsAndInterestsViewModel {
  id?: string
  name?: string | undefined
}

export class AddInterestCommand implements IAddInterestCommand {
  name?: string | undefined
  contactId?: string

  constructor(data?: IAddInterestCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
      this.contactId = _data['contactId']
    }
  }

  static fromJS(data: any): AddInterestCommand {
    data = typeof data === 'object' ? data : {}
    let result = new AddInterestCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['name'] = this.name
    data['contactId'] = this.contactId
    return data
  }
}

export interface IAddInterestCommand {
  name?: string | undefined
  contactId?: string
}

export class EditInterestCommand implements IEditInterestCommand {
  id?: string
  name?: string | undefined

  constructor(data?: IEditInterestCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
    }
  }

  static fromJS(data: any): EditInterestCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditInterestCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    return data
  }
}

export interface IEditInterestCommand {
  id?: string
  name?: string | undefined
}

export class ListUserTrainingCoursesViewModel implements IListUserTrainingCoursesViewModel {
  id?: string
  name?: string | undefined
  graduationDate?: Date
  provider?: string | undefined
  country?: string | undefined

  constructor(data?: IListUserTrainingCoursesViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.graduationDate = _data['graduationDate']
        ? new Date(_data['graduationDate'].toString())
        : <any>undefined
      this.provider = _data['provider']
      this.country = _data['country']
    }
  }

  static fromJS(data: any): ListUserTrainingCoursesViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserTrainingCoursesViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['graduationDate'] = this.graduationDate
      ? this.graduationDate.toISOString()
      : <any>undefined
    data['provider'] = this.provider
    data['country'] = this.country
    return data
  }
}

export interface IListUserTrainingCoursesViewModel {
  id?: string
  name?: string | undefined
  graduationDate?: Date
  provider?: string | undefined
  country?: string | undefined
}

export class AddTrainingCourseCommand implements IAddTrainingCourseCommand {
  contactId?: string
  name?: string | undefined
  graduationDate?: Date
  provider?: string | undefined
  country?: string | undefined

  constructor(data?: IAddTrainingCourseCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.contactId = _data['contactId']
      this.name = _data['name']
      this.graduationDate = _data['graduationDate']
        ? new Date(_data['graduationDate'].toString())
        : <any>undefined
      this.provider = _data['provider']
      this.country = _data['country']
    }
  }

  static fromJS(data: any): AddTrainingCourseCommand {
    data = typeof data === 'object' ? data : {}
    let result = new AddTrainingCourseCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['contactId'] = this.contactId
    data['name'] = this.name
    data['graduationDate'] = this.graduationDate
      ? this.graduationDate.toISOString()
      : <any>undefined
    data['provider'] = this.provider
    data['country'] = this.country
    return data
  }
}

export class ListUserSpecialProjectsViewModel implements IListUserSpecialProjectsViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  date?: Date | undefined
  specialProjectStatus?: number
  alumni?: string
  alumniName?: string | undefined
  specialProjectTopicId?: string
  documentUrl?: string | undefined

  constructor(data?: IListUserSpecialProjectsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['Id']
      this.name = _data['Name']
      this.description = _data['Description']
      this.date = _data['Date'] ? new Date(_data['Date'].toString()) : <any>undefined
      this.specialProjectStatus = _data['SpecialProjectStatus']
      this.alumni = _data['Alumni']
      this.alumniName = _data['AlumniName']
      this.specialProjectTopicId = _data['SpecialProjectTopicId']
      this.documentUrl = _data['DocumentUrl']
    }
  }

  static fromJS(data: any): ListUserSpecialProjectsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserSpecialProjectsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['Id'] = this.id
    data['Name'] = this.name
    data['Description'] = this.description
    data['Date'] = this.date ? this.date.toISOString() : <any>undefined
    data['SpecialProjectStatus'] = this.specialProjectStatus
    data['Alumni'] = this.alumni
    data['AlumniName'] = this.alumniName
    data['SpecialProjectTopicId'] = this.specialProjectTopicId
    data['DocumentUrl'] = this.documentUrl
    return data
  }
}

export interface IListUserSpecialProjectsViewModel {
  id?: string | undefined
  name?: string | undefined
  description?: string | undefined
  date?: Date | undefined
  specialProjectStatus?: number
  alumni?: string
  alumniName?: string | undefined
  specialProjectTopicId?: string
  documentUrl?: string | undefined
}

export class ListSpecialProjectTopicsViewModel implements IListSpecialProjectTopicsViewModel {
  specialProjectTopicId?: string
  specialProjectTopicName?: string | undefined

  constructor(data?: IListSpecialProjectTopicsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.specialProjectTopicId = _data['SpecialProjectTopicId']
      this.specialProjectTopicName = _data['SpecialProjectTopicName']
    }
  }

  static fromJS(data: any): ListSpecialProjectTopicsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListSpecialProjectTopicsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['SpecialProjectTopicId'] = this.specialProjectTopicId
    data['SpecialProjectTopicName'] = this.specialProjectTopicName
    return data
  }
}

export interface IListSpecialProjectTopicsViewModel {
  specialProjectTopicId?: string
  specialProjectTopicName?: string | undefined
}

export interface IAddTrainingCourseCommand {
  contactId?: string
  name?: string | undefined
  graduationDate?: Date
  provider?: string | undefined
  country?: string | undefined
}

export class EditTrainingCourseCommand implements IEditTrainingCourseCommand {
  id?: string
  name?: string | undefined
  graduationDate?: Date
  provider?: string | undefined
  country?: string | undefined

  constructor(data?: IEditTrainingCourseCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id']
      this.name = _data['name']
      this.graduationDate = _data['graduationDate']
        ? new Date(_data['graduationDate'].toString())
        : <any>undefined
      this.provider = _data['provider']
      this.country = _data['country']
    }
  }

  static fromJS(data: any): EditTrainingCourseCommand {
    data = typeof data === 'object' ? data : {}
    let result = new EditTrainingCourseCommand()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['id'] = this.id
    data['name'] = this.name
    data['graduationDate'] = this.graduationDate
      ? this.graduationDate.toISOString()
      : <any>undefined
    data['provider'] = this.provider
    data['country'] = this.country
    return data
  }
}

export interface IEditTrainingCourseCommand {
  id?: string
  name?: string | undefined
  graduationDate?: Date
  provider?: string | undefined
  country?: string | undefined
}

export class ListUserDocumentsViewModel implements IListUserDocumentsViewModel {
  identifier?: string | undefined
  fileName?: string | undefined
  contentType?: string | undefined

  constructor(data?: IListUserDocumentsViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.identifier = _data['identifier']
      this.fileName = _data['fileName']
      this.contentType = _data['contentType']
    }
  }

  static fromJS(data: any): ListUserDocumentsViewModel {
    data = typeof data === 'object' ? data : {}
    let result = new ListUserDocumentsViewModel()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['identifier'] = this.identifier
    data['fileName'] = this.fileName
    data['contentType'] = this.contentType
    return data
  }
}

export interface IListUserDocumentsViewModel {
  identifier?: string | undefined
  fileName?: string | undefined
  contentType?: string | undefined
}

export interface FileParameter {
  data: any
  fileName: string
}

export class ApiException extends Error {
  message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isApiException = true

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result)
  else return _observableThrow(new ApiException(message, status, response, headers, null))
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('')
      observer.complete()
    } else {
      let reader = new FileReader()
      reader.onload = (event) => {
        observer.next((<any>event.target).result)
        observer.complete()
      }
      reader.readAsText(blob)
    }
  })
}
